#include <iostream>
#include <string>
#include <set>
#include <vector>
#include <map>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <conio.h>

#include <boost/lexical_cast.hpp>
#include <boost/assign.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>
namespace fs = boost::filesystem;

#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>

namespace
{
    typedef std::map<std::string, std::pair<std::set<std::string>, std::set<std::string> > > Matches;

    ///////////////////////////////////////////////////////////////////////////////////////////////
    std::string reverse(std::string const& s)
    {
        std::string rv(s);
        std::reverse(rv.begin(), rv.end());
        return rv;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    typedef std::map<char, double> MonoisotopicMasses;
    MonoisotopicMasses const masses = boost::assign::map_list_of
        ('A',   71.03711)
        ('C',   103.00919)
        ('D',   115.02694)
        ('E',   129.04259)
        ('F',   147.06841)
        ('G',   57.02146)
        ('H',   137.05891)
        ('I',   113.08406)
        ('K',   128.09496)
        ('L',   113.08406)
        ('M',   131.04049)
        ('N',   114.04293)
        ('P',   97.05276)
        ('Q',   128.05858)
        ('R',   156.10111)
        ('S',   87.03203)
        ('T',   101.04768)
        ('V',   99.06841)
        ('W',   186.07931)
        ('Y',   163.06333);

    ///////////////////////////////////////////////////////////////////////////////////////////////
    typedef std::map<std::string, std::string> RnaCodons;
    RnaCodons const codons = boost::assign::map_list_of
        ("UUU", "F")      ("CUU", "L")      ("AUU", "I")      ("GUU", "V")
        ("UUC", "F")      ("CUC", "L")      ("AUC", "I")      ("GUC", "V")
        ("UUA", "L")      ("CUA", "L")      ("AUA", "I")      ("GUA", "V")
        ("UUG", "L")      ("CUG", "L")      ("AUG", "M")      ("GUG", "V")
        ("UCU", "S")      ("CCU", "P")      ("ACU", "T")      ("GCU", "A")
        ("UCC", "S")      ("CCC", "P")      ("ACC", "T")      ("GCC", "A")
        ("UCA", "S")      ("CCA", "P")      ("ACA", "T")      ("GCA", "A")
        ("UCG", "S")      ("CCG", "P")      ("ACG", "T")      ("GCG", "A")
        ("UAU", "Y")      ("CAU", "H")      ("AAU", "N")      ("GAU", "D")
        ("UAC", "Y")      ("CAC", "H")      ("AAC", "N")      ("GAC", "D")
        ("UAA", "Stop")   ("CAA", "Q")      ("AAA", "K")      ("GAA", "E")
        ("UAG", "Stop")   ("CAG", "Q")      ("AAG", "K")      ("GAG", "E")
        ("UGU", "C")      ("CGU", "R")      ("AGU", "S")      ("GGU", "G")
        ("UGC", "C")      ("CGC", "R")      ("AGC", "S")      ("GGC", "G")
        ("UGA", "Stop")   ("CGA", "R")      ("AGA", "R")      ("GGA", "G")
        ("UGG", "W")      ("CGG", "R")      ("AGG", "R")      ("GGG", "G");

    ///////////////////////////////////////////////////////////////////////////////////////////////
    typedef std::map<std::string, std::string> Sequences;
    Sequences GetFasta(std::string const& file)
    {
        std::ifstream in_file(file.c_str());

        Sequences sequences;
        std::string current_name;
        std::string current_value;

        std::string line;
        while (std::getline(in_file, line))
        {
            if (!line.empty())
            {
                if (line[0] == '>')
                {
                    if (!current_name.empty())
                    {
                        sequences[current_name] = current_value;
                    }
                    current_name = line.substr(1);
                    current_value.clear();
                }
                else
                {
                    current_value += line;
                }
            }
        }
        sequences[current_name] = current_value;
        return sequences;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    std::string ToRna(std::string const& s)
    {
        return boost::replace_all_copy(s, "T", "U");
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    char Complement(char c)
    {
        switch (c)
        {
        case 'A': return 'T';
        case 'C': return 'G';
        case 'G': return 'C';
        case 'T': return 'A';
        default: throw std::runtime_error("Complement()");
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////
    std::string ReverseComplement(std::string const& s)
    {
        std::string ss = s;
        std::reverse(ss.begin(), ss.end());
        for (std::string::iterator itr=ss.begin(); itr!=ss.end(); ++itr)
        {
            *itr = Complement(*itr);
        }
        return ss;
    }
}

/*
///////////////////////////////////////////////////////////////////////////////////////////////////
void P01_Counting_Nucleotides()
{
    std::string const s = "CCTTAGCCCTATGTTGACCGTCTGGGGAATAGCACGTGCGAAGCGCAAATACGCCGCACAATGGCACAATTTTGTAGCCTATACCTCATTGCGTCTACCAGGTCGTCCGGGAAATGCTGGCTAATTCCGGAATACCACCCGAGTCTTCCTGCGACTCTCAAGATAAACTATGACACAGTCAGGCAAGGTCTGAGGTCGATTTATAAACTTGCAACCTTTTATACCATCCGGAGGGTTAGCTAAGAGTAATGGCTGAGTCGTGTGCGGCCTGCACTCCGTAATCCTCAATCCGTAACAACGAAAGAAGCACAGACAGTACGTAGGAGTCCCGGCGAGACTTTCCCGGGCACGCTAAGGTCGATAAACCTTCTCACCACTAACTTCTCGCCGCATATTTTAGCCATCGCAAGGAGAAATAACCTACTCAGACGTGGTGGCACGCAGGTCCAAGAACCGTATCATCCGTCCTACACCCGTACAGTGGGCCGGGCCCCCGAACTACAACGCGTATGACAGGGAAACTTATAACCCGTAACGCCATCCCTAGGTCGCCTTGTAAAGGTCTTGATGATATGCCCGAGGTACAAACTTCACTATGTACGTTCTTCTCACCATGGAAGTCCGTGGTCTTGACGAGTGGTGAGGGCGGGAATAGGCATTAGTGCAGTTCTGTGAGGAGTCATTGGCATTCACACGACGCCCTCGGAATACTATACGGATTATCGGAGTTCCCGGATCGCCACGAGTTCCCTGAACACGAGGACTGTTAACCTCGCGAAACCGGAGGCCCCGTGGGACCGGTCCTGCTGACCGGAGGAGTTCACATTCTAATTTTGAGGGTGCTA";

    std::map<char, long> v;
    for (std::string::const_iterator itr=s.begin(); itr!=s.end(); ++itr)
    {
        ++v[*itr];
    }

    std::cout << v['A'] << " " << v['C'] << " " << v['G'] << " " << v['T'] << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P02_RNA_Transscription()
{
    std::string s = "TCAGGAGTAACTTGGTGTTGCGGTCTGGACCATCGCTCAACCCCAGTTAAACAGGCACGAACCTTGGAGTCCGTTCCCAGCATACGTTCACAATCAAGGTGAGCTAGTTGCTCCCCTTGAGCAGCATCAATACCTCATGCTTGAGGCCCTAGAAATGGTCGTCCAGCTAGCATGACACTGTAACGTCACGACACTGTATGATAGCTGGTCGCAGACCCCCTGCTCTGAGGTCACCTTCGTCAAATACGCGCAAGTTAATCGAGTATGGCGCTACTGCATGTCGTTAACCGGGCTTAAAGTTCACGCTGCCTGTATGAAAGATCGGTTCAGGAATTGGCGTACTGATACGTCTCGTCAGTGCCATTAATCAGCGGCGGGCGAAACGAAGGGGACGTGTACCACGCTCCGTGGTTTCGAATGATGACGAGATATACAGTGGCATAGACGTCACTATTAACCTGACATTTCAGTTGGTTGCAAGTGTCAACTTGCCCCCGCGCCGCTAATTTGGTGTGTTTGGAGCTATGAATCTCGGTTTCTCCATTGTGGCAATGGACTGAACGAGTCTGAGTGAAGAAGTGACTAAGTCAGGCCTTCGCCGTGCACCATAGGCGGCTGCGTATCGTTGGGTAGTAGATGATGTCAGAAGACGGGACGTAAAGGTACAGTCGTCGCAGAGCAACCTGTCGTATGATGCGCGAAGTTCCCCTTCTAAAAGAGGTGTCAAGAGCGATTGTGCTACTCTGAAGACCGCGAAAAAACCTCGGAATCAGCTGATGCTCCCAGTACAGGCATGATTGCACAGTTCCTCTTTGTCGCCGCATAGTACGATTTTTGATCTTCATGAACTGTCGTAAGCTAGTTGCCAGTGGCATTGATTGAGTTAAAACGCTTAGACATATTGTTCTTTTTCCTTCGCGCAATTCCTATCGGATCC";
    boost::replace_all(s, "T", "U");
    std::cout << s << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P03_Reverse_Complement()
{
    std::string s = "TTCTTGATGGAGGAATTTATTCAGGGCTTTCTAACGTCACAGCGCCATTCAAAGTTCCGCGCGCGTACAAGCCCTGGCGCAATGAGGAGCATCTGCCAGATAGCCGTAGTAAACACTGGCGATAAAGGCTGTCTTGAGTATACCGGTGGTTTCAGGGTCGGAGCTAGGTTCCCGAGTGAGTACTGTCTGTCCCGCCTGTGAAACAATTACTGCACACGAACCACACTCCCATGGCCTAGAACTATGCATAGGTCTCCGCTAGTAGTCGCTGAGTGTCCTTCGCTAGGGCCCGGAGGTGTATCCGCAACTAATATGACACGGAACCTGTTGTGATAGTTACCGAAGAGTCTTCAGCCTTCATTGATCTGTGGCTTATACGTGAAACAAACCTCTGACAGTTTTAAAACGAAACATGTATTTAGCGAAACTGTCCTCTCTTGCTTTGTTCTTGCGAGCTGTGTATCCCAGGGCCAAAAGTTTATGTCCTAGTAGCGTCGGCCCTGGAAGCTTGAACAGGCCTTCTAGAGGATCCAGGGTTAAGATGACCTCAGAAGGCCGGATCCACTGCTGCCGGATTGATTCTGTCCATAATGCTACATGCTCGCGTGTGTGTGCCAGCGCATGTAGAGAGTGCCGCGCCCTGGATTGGCTCGATTCCCTCCTCAGGCGATTCAATTTCCTCTCGTTCTCGCCCGCCCGGCACATGGTTGTGGAATAGCTTAAACACTTATCGTCGTCTTCGTAACCCGTCGGAACGAGTATAGAGAGGAGCCGCGGTATAATACGACAGATCGCACTTTAACGCGTTAAATGGGGCTTGCCCCCGTTCTTGTAGACGTATAATGTTCTTATCTCGGCTTATCACACACCCCTCGGCCGGGGACTAATTCGAAGTTCATTTATGTGATATCCGATGATTGGAGTGTTTTGGCTTAGAGAGCCCCTTATTTTTTGCCTCGGT";
    std::reverse(s.begin(), s.end());
    boost::replace_all(s, "A", "X");
    boost::replace_all(s, "T", "A");
    boost::replace_all(s, "X", "T");
    boost::replace_all(s, "C", "X");
    boost::replace_all(s, "G", "C");
    boost::replace_all(s, "X", "G");
    std::cout << s << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P04_Counting_Point_Mutations()
{
    std::string const s1 = "TGTGTCTGACTTGAGTGACACAGACGGCTGTGTGCTTCTGTGGCTCTAGAAGGCGGTGTATCAGATGTTCGTCCATGAACGGTGGGATCAAAACTTGTTATAACAACCGTCACCTCTGTTTCTCCAATTCACAGTTTTTTGTTAGTACCTTAGATCCCTTAATGAATCGTGATACCTCGAGCCAGCGCATGATTCATCCAACGTCTCACAGCACGGCCAGACCTCTACAACACCACGAAACGGCGGATTGTAGCTGTATCCTTTGATGCAAGTGGTAGGAGGACAGTGGTATATAGGGCATGCCAGCTCAAGAACCGAAAAGCAAGACGAACATGCCGCGACCTCTGCGTCTCGATTCGCCGCTACTCCGAGACAAAGCATAAGCATCAATCACCGTAGCACGTGTCTGCAATTTCTAAAGCCTAGTTCGCGAGCGTTCTAACGCGAAGCACATCGCGACTCGAAGAGAGCGTGATCCACCTGCGCCTTAATCTCCTCTCCTGAGTCTACACACGCGGCCCACTGCACGAACGCCCCAGTTTGATTGTTGCATCTACAGGAATACTTGTTTGATCGTTACGGTGCCATACACGGACCAGTGTGCACGGTTAACCCAACCATTGTGGGTGAGCGCGATTTAATGATCCTGGCCTGTAATTTAAAATGTTAGGATCTCTGCCGTCTGTGGCTTCCCTATGCACGTTTCCAGGACAATATCGGATATGGTGGGCGTACTTTAACGTTATTTTAGTCCAAGGATCTAAGTCGCTTGTTCGAGTGTTGTTGAAGCGCAGGTTATGATGAATCAGGGGGATTTATCAGAGTAAGACCCGGACGAGTACTAACTCCAGGGCATTGCCGAGTTTCAATACCATCCGAGGCTGAACGTATCTCCCCCAACTCGGGCCGAACTCCAGTCCGGTGTGCGTACGCTAAGCAGGTAGCCAGGGGTCGCAGTATAGATAGCTGATG";
    std::string const s2 = "TCTCTATGACTTGCCCGATACACAGGTCCGTAGGACTATGGGGGATTCGCACGGGGCGCAAAATATTACTGTACGAGAGCGGTAATGACGAAAAGTGATATCAGCATGCCCGCATCCCTCAAATCTACGCGCGCGGTTGTTCTAGGTTCTTAGCTGCTAAAAGGGTAGCTCCGACCTGACGCCGGAGCTCGAATGATCTGTCGTCTTCTGCTTCTTTCAACCCTCTACTAACAAATCAGCTAGCCAATCCTGGCTGAATCATTTTACCCACAGGGGGGGACGTTCATTGGATTTACGAGATCCTATCTCGAGAATAGCCAAGCCCGACGACGTTGCCCTGTACTATTAGTCTCAAAAACGCGCCACAGATAGACCAATAATCAGCGTCCACTTACGTGGCCAGGGTTGGGACGCTCTACGGGATGACGCGCGGATCAGTTCACGATAGGCCCACCGCTTTGTCGCGAGTGCCTGACCTAGGTTCACCTAAACCTGAATTCTTGAGTCGAAACAGTGTCATTGCTGAACGTAAGTCATAGGCTCATTGTGGCATCTCAGTGACAAGGCCTTGGTGGGCCCCTGGCCCTTACACGTAGAACTGAGTACGTTTGCCTCATCTTATGCTCTCACGGGAGTTTCCTTGTTCCGGGGCTTTAATGAATTACCCTATGTACTGTGAGTTCTGCGTATTAGACTAACAGGTCCTGCATCCAACCGGCCTGACGGGCGTCCTCTCGGTTAATGCTTTTAGCCCACAGACGTAGACCTATCGAAAGCCTCGGGTGGAAGAGAGGGTTCCGCTTTGTTTGGCGGAAATGAAAGTATGGGGCCTTGATGAGAGTGGACTTGAGGGCACTGGCCCAGTTATTTACTCGGGAAGAAGCTTCCACTCCCTGCCATATACAACCTCCTTAGCGGGCGGCAAGTCTACGCTTTGTTGGACTCCGGCCCGGGCAGATTGAATCGCAGATA";
    
    assert(s1.size() == s2.size());

    std::size_t hamming = 0;
    for (std::size_t i=0; i<s1.size(); ++i)
    {
        if (s1[i] != s2[i])
        {
            ++hamming;
        }
    }
    std::cout << hamming << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P05_Protein_Translation()
{
    std::string const s = "AUGCCUGAUCCCGCCCGAAACAUUCAAGAAACAAGUGUCGAUCAGACAAGAUGUAGACUCUUUCGUAGUAAUCCUGACAAGAGAGGAAUCUAUAAGCCUAGACCCGAUCGUUGUCACAAGAUGCUGCCCGGUAUGGCUUGGAUGGUCCAAAUGCGGCCUUCUAUGAAGACCUGCCUUCUGCGGGAAGAGACGCUAAACGGAGCGGGUCUGUGCGGCCAGCACCGAAUGCUUACAGGCCCGUUUUGUCGACCCUUCAAGGGUCUGCGAAACCAACGAUGUUGUCGGCGUCAUGACUUUGCUUACGCACCUUACUCGAGAUACCGACGAACAUAUGUUUAUUCUACCCGACCUUGUAUGGAGAGUGUCGUAUCUGCUCUAUUCAUCACUAGUCCAAGACGCGGAAGCAACGAUGCGACAAGUGAGUGGGCGUGUCAUAACUCAAGUCACGCAGAAUAUAAGGAGAGCCUCUUUAUGUUGUUCUCACAAAAGAGCGUAUCCGAUGGGCAAACUGAACUAAUCGAUGCACGUUCACUUAUGCCAUCGCUAUGGACUCUAGAAGGCCGGAAACAGGGACCGGGCACCGUGGUCCUUGGUGUAUGCUUGGUGCAGAAAGGUUUAAAAUCAAAUGGGCGGAACGGGGCCAUUGCGACAAUUAAUUGCUUUACCUCCCUCACUGCAGAACAAAUAUCCUCAUCUCACCUGGGGGCGAUCAACGACCUCCAGUCGGUUAUUAGGCAACGAUCGCAAGUAGCGCGUGCACGUAUAUACGGGCUCCGACCAUGUUACUGUCGCUAUUCUAUAGAAGUUGGCCUGCACUGUACGAAAGACGAGAAGCAGACCUUAUCCCGGCCCCUCGGAUGGAUGUCCUUCUCCCAACUAUACCCUAAACGGCUGGCGAGCGCUACGAAUUGGAGAGUGUGGUGUGCGCGAAUACGAGGGGACUGGCUCCAAAACCUAAGGGACUGCUUAAGUCCGCAGGGCCUCGAACCGCCACUAACCAGGCAAUUUUUAAGAAUCCAAACUAGAAGCUGGCGGAUAGGUCUAUACCAGAUCUUCACGGAAACGUCCGUCGGAUUGAUGGACUUGGGUUCGGAGCCCGACACGUGGCCAGCGGCUUCUGGCACGGGCCUCCCUCCACAUAAACGGAAGAUGCGUGCGCCCGUUUUGCCGCUUAGUUGUUCAAAUGACAGCAACCGCGAGAUGAUUCCAACGAUAGUACUUGGUUCCCGGGAUCGCGCUACCGUGGUCGCGUUGGUAUGCGUUUACAUGAGCCUCAUCAUCGGUUCAUUAUCGGUCAUAUAUCGGCGGUCCUGUGGCCUCAGCGCCAGUAAACUCUCUCUAAUCAGGUUAAUUCCAAUUUGCGGUGGUUGUUGUCGUGAGGGACGGUUAGCAGUAUACUUCUUUCCCCCGAUAACCCCCCAUUGGAGGACGGGACCGUGGCUAGCAGUCAGGAGGGGAAGGUGCCCAGGACGCUAUUUUUCGGAUGUUUUCGAGCUGGGUGAACCAUUAGCCUUUACCGGUGAGCCCAGGGUGCCCGGCUGCAUGCAGCGGCGAUUUCAGGAACUGCCUAUUAAAUAUUUAACCCUAAUCACGGGUAUGAAUUUGCACAUUAACAUUUCAAACAGUGUCUCCUCUGAUCGGACUGCCAGCUCCUGGCUGCAAGCGACGCUGGGUCCCAUCAAGAGGUGCUCCAGUCUACGUCUUAGUUCCGUUUUAACAGUUGUGGCUAGACUGUGCCGAACCGGACUGACCCCCGUAUCUCGUAGAUUGGUCAGAAGCCUGCUGUUCGUUAUGUGGUUAGGACUAAGCAUCCGCGAAUGCUAUGGUAGCAAGGCUGCUAUUUGGUCACGUUGUCGACAUCGACCUCUCCUCGUCCAUUGGCUAUACUUUCCGCCAGAGAAGCGUCCGUUAGUACGACCAGUGGGUAAGGCCGAAGCCAGUGGUCUAACCCGUGAAACGCACGUACUAGGGUGGCCCCCGACAGAACGUAGAGCGCAGAGAGAAGGCGCUAAGGCGGAUAUCCCGCGUUUAAGCUUAUGUGCCGGCUGUGCGUAUAUUCCACGUCAACGCUCGAAUUACGUACGCAUAGAUACGCCUCAAGGGCCCCAACGAGGGCACGGUGCUAUGUUGUCCCAACGUCCCAGAGCUACCCGCAUGCACAAUGUCGUCUUGGCGCACCAGGUAGUUCCUCCAACUGUCCGGAUCCAUAGGGAACAAGCUUUGCUUCGUGUGCUGUCAUCAUGGGCAUCAGCGGGACAAAAUAGUCUAAGACGACCUUGCCCACUCCAUAUUCCGAGAGACCAACCCGCCCGCUGGUAUGAUGCCCUUCAACAGCACAAGAUCGUCCACGGGUGCCAAGGACAUGGCCUUGGCCCUACAUUCCGGCAGAGUUACAGAACAACAGCAGAAAGAUCAUCUAGCGCAGCCAAGAUUUCUGAAUUCCACCUUGGCGGCUGGAUAGGCAUUUCGGGGGCUAUCCGAGCACGGAGGGCUACGUCCCGUCCUUGUAGCAGUGACCAAUUAGCAGAGCAGACCAAACUGCAAGAGCAGAAGCUCUGCAUACAAUACCGUCUUCAAGUUCGCACCCGGAGGCUAAAGGAUGUAGAAGUACAAGUUUCCCUUGUGUUUGACGCAGAUCCGCCCUUAGUCGAAUCCUUGUUUAUCUGCCUGAGUGAGUCUGAUUCGCAUCGGGCUGUAGGGUUAAAGCGGUUGCAAGAGUGGAAACCGGAUGACUUCUCGCAUAGUAUUCCUAAGGCUAUGAAGGAAAUUUCCCGAUGUAAAGUAGAGGAUUUGGAAAUAUGGAGCUACCCGCAGACUGUACGUUCAGGACACGUAGUAUCUUGCGCCCCUCCUGAACACGCAGGGUGCUCGUCGCUAGACGGACUCAGAUGGCGAUUACGGAGUGAUCCCGGUCCUUGUACACUGAUAAGGGCACCUGUGGUUGGGAGGCAUUCGUUCCAAGACACUGUUGGUGGUGAUUGUCUGUGCAGGAUUCGCGCUAAAGUACGACUACUGUUUGCUUUUCGCAUGACGCGGGCAGUGAUGCGAAACAUACACACUCGUUUAUCUGGCCCACCGGACAACACUGGCGCUGCGCAAAACCAGCGACCUGAGAAGAUCCAAAUCUAUGCACAACUUAAGCGCAGUGUUCUCUCUUGCAUUCGCGUCAACAUAAGGUUCAAAAUCGAGCAGAUUUGCGAUAGAGCAGCCCUGCGUGCCACACCUAAAGAGGGUUGUUACAUCCGCCAUAGGCUGGAGAAAUCGCAUGAUACAUUAGCGAUGGUGAUGCACUGUGUACAUUCUGGGCCAAGAAAGAGUUUGAUUCCAGGUGUUUGUAGUGGGACCUAUCAAAUGGCCAUCCUGUCGUGUUUAAAUAUAGGACCCGUCCCCGGUGCAUGCAUAAAGAAUCGGACCUUAUCAAUCUGCGGGAUGUGUAUAUCAAGCAGGUCCUGUCCCGACCCACAAUCCGUAUUCUUUGGACUGCCCCUGCUAGGGGUGGUGAGGCUCUUGGCAUUGUAUGCACGUGGGAGAGUUACAGGCGCGGUUUACGUUUCUAGUGGACUCACUGGAAAGAUCGUUUAUUUCGUAAUAUGCAGGAUUCCUUGGUGCAAACUGGUUAUGCUUAGGGGUUGUCUUAACCACCGGUAUAAAGUUCCGUUCCCCAUCGCCCUAACGUCGAGACCUCUGAUGCCAUUCGUUUGUACACUUGACAGGGGUCUCGCAAAUAGGCGAACCGAAAGUCAUUCAGAACAGCGGACUUCAGUGGGUGAACCGAAAGGACUAUGGGUCGUUGUUGACAUAGUCUACAUAACCUAUAGCCUUUCAGCUGCAGUACGUCGCGCCUUCAUACCCGGGUACAGCAGUCCCCUGUCGCUAAUGGAAGUCCAUAAACGGGGUAAGUCGCGUAAACACAUCCCUCAAUCCCUCGACAAACGAGACGUUCGGUGCCUUUGUGUCCAACACUAUAAAUGGAUGGAGCCGCACGAGAUAACUUUUACCGUUUACCCUCGACUUCUCCGUUUAUACAUUGAAAAAGAAAUGACUACACCUUCCUUCCCCAGAAUCUUCCCCGUAACCAUACAGGUGUUUUACCGGUCCCAAGUCCGUCUCGGGACUAUCCGACCACUUGGUGCCAUACCUAAACAAACACGAUCCUUGAUCCCUGCAGGGCAUGAGGUAGUAGAAACUCCCAUGUACUCACAUAGCAUAUAUAGUAUAUACAACUUGAUCACCUUCUCCGAUGAAUGGGCUGAGACCCAAUCUCGCCGUCUUGUUAUCUCGGUUUUCGGGUUGGCUGCGGCAAUGCGGGACUUGAUGUUUAACAUGAGAAAAGCAGAAAAUAGGUAUAAGGUUCCUGACCCCCAUCUCGGGUUGCUGACUGGACACGAUCGAAUUCACCCGGCCAAUGAGCGCAUACGGCAAAGCCGACGGGUCAGACUGCAGAUGUUAGUAGUACGUACACUCUUUAUCGUAGCGUACUCUACUUCUGAGGGGUUCGACGCUGUGUCGGGUUCGCCUUCUUUUUGUGUUCGCAGCAGGCUGUGCUUAGGGGGCUCAGACGGCCACACAGAAUCAUUUCGAAUAUUCUGCCGGACGACAGUACCAAUCGGACGCUUAACGCAUUCUGGCCCACUGCCAUCUGGUCCCAUUUUCGCACGCGACAAAUGGGAUGACUGGCCUCUGAGCUCGAAUCCGUUUAUGUCACCUAAUUCAGUACCUGAUCGAUUCAGCUACCACAUAGACUCCGGGGGACGUUCGCCACCACUUGCUGUUCUUAGUAGCCACCAUCUUCAUACGACUGAUUAUCGUUUACCCGGGUCCGGAACACUGCCCAGCUGGCUCAUAGUCGUAAGUGCGCGGGAUCGCGAUUUCACGGUAGCUGUAACCAGUUCACUCACGUUGAGGACCCACGGGUCUAACGUACCUGCUUACGCGCACGGGAAUGCCAUAACGGAGGCGAAUGUAAGUUCUCGGGACGAUAGGAUUGCCGGGUCGGAAGAGCCUCGCAUGCAGUUCCGACCGCCUUCGUUGCACCUGGCAAUAAAGGGCACAACCACUAGCCUGCCUCUAGUUCCCGAAAAGGCGUCGAAACGCUUUAAAGAAAGACUUCGGGUACGCGUUUCCUGGAUUCCUAUUCAUGUUUGUGCUGUUGUUUGCCCGACCGUGGAACGAGUAGAGUUAAGCUCUGUCAUGCACCGAUACGGCUACUCUCAGCGUGCACAACAUGGCGGGGUCGUUACAUUCUUCUUAUUCGCUGUAAAACGAGUUGAUGACUCAUUCUCAAUACUCUGUUACUGGCGCUGGAGACAUUGUCUGAGGAAGCCGUAUACCUCAUCCCCUAGUCGGAACUGCGGCCAGAAUGUACGGGUGCUUACUGUCGAGAGUCACGUCUGCUCGAACCCUCGCUGUUUCCAAAUAGCAUCAACGCUAGGGACUACUUACACGCAUGGUUUGGGAUCCGUGGCGACGAGAUCAGUGACGGAUCAUCGGCCCACUGUCCUUUUACCAAAUGUCUUAGUUAUACGCAGUGCCAGGACGCUCUGUGCUGCCCACGCUAAGUAUAGCCACCUGAGGCUCGUACUCCGGACGAUCUUAAAAGAUUAUUAUAUUUGGGAGCCAAACCGUUCGGUGUUCCACUGGAAGCGUAUCAGGGGGACUUACCAUAAAGCUCUUGAGAGCUAUGCCCCGAGUAAUCGACGAGGUCGCAGUAUUAACAGAUGUGGGCGUUUCAGAUCGUUGCACGCGUUAGUACACUGCAAUAUAACCCGAAGCAGCAACGAGCGUUUCUCCAUUUCUGCGGGUUUAAUGGCGACGAUACCAAGCUGCCUCGCGCAACAGGGUCCCCUCCCUACGUGUUGCCAAAAUUUAGCUUGCACGGGACCCGUCUCCCCUGGGUUCCAGCGAGCCUUCGAGACGAGUGGUGGGGGGACCUUCUAUAACGAUACCCCAGAUAGGCGGAAUCGCGGGUCUCGUGGAAAUACGGCGUGCAUCUGGUCCUCUAGCGGGUCAGGCGGUGACCUUUUCAUUCAAUCUCCUUCACCCGCGAUGCGUUAUACGCUACAACUGCAUCCAUUUACACAAAACGUGAAAUCAGCUUAUAGCCGACUUCUCAGGCAUAUCAAACAUGACGCAGUCGGCUGGCGGGCUAGAAGAGGAUCGUAUAGUGUCCGAAACAUUGGUACGACGGCAGGAUAUUUGCUGCGGCCCUGCUCGACGAAAACGGACAACUUUCCCCCAUGGCAUGCAAUCUGGUAUCCUCGGCGUAGGUACGGAUCAAUGGAGCAACGAUGUAAAGGCUGUUGCAGAGUGCACAUCUUACUAGGUAUGGGUUUGCUCCCUAUAGAUUUUCGUAUAAAUUCUGGUUCCUGGGUUGCGACUGACAAGACUCUGCAAAACUAUGAUGAUGUCCUUUGGUUGUAUUGGAACUCACACUUAGAACCGCAUCCGUUAAUCUCUAACUAUGAAGGACAAUGCAUGGGUAGUCGAACGCUAGGAUGGCAAAGUAAAACCGCCGUUCAGUUCGAUAAUUAUGCUGUCGGUCUACGUACGCCAUCGCUCCCUUACAAUAAAUCGGCACUAACAUAUACUGUUACUCGUUGGAUUGUCGUGCACAAUGGAACAGCGCGGUUGCAGCUCUCGACGGAAAAUACGUGUUUCUUUCGAUUCCGUCAGCGUCAAAGUUCCAAUAAGGACAGUGUGUAUCGUAAAGGAAGUAGGCUCGGAACUGGUAAACUAGAAGGUCGAUGCGGCGGGCGACACAUUGGUGCUACAGCGACUGCAGAUCUGUACGGCAGGGGCUUGCUAGAUAACUUAAUCCAGUCCGCCAACUGCUUUCUCAAUGGCACAGUGAGUCCAGAAAAAAGAGCCGCUGGGGGAUCUACGAGCUCCGUUUGCCAACGGAGAAGCGUGAUCGCGUCUCCGUACGGAGUCACGGGACUGGUACAAACCAUUCACCUCGGUCCUGGCGACGGGCCAGGCUGCCAUGCCCAUACAAUUGGGUUUAGCCUUAAAAGUUGUGAAAGUUUUAGAGCUGAACGGGAUAUGUCAGUUCCCGGGGAUAGUUAUUUUGGUGUAGUUCAAAUUUCAGUGCUGGGACCAGUCGGUCGGAUCGGCAGCAACCAUCCACACCUUAACGUGGCCGUGUCAGGAGCCGUGACUACGAGUUUACUGGAAGGAGGGCCGGCGAAACCCGGUGGUACACUGAACGUCACGUCCUCGAAAAUCUCUUUCAGUAGAACAUUGUAUUAUGCUCACCCACUGUGCACGGGGACCCCGCACAGGACCCAUUUUCUCGACUGUGCAGCUCGCAAUCACAUGUCCCUGCUUUACGGGUUGCGCUGUAGGAUUAGUUUUGCACUCUACCCCCAAUUCGCAAAGUUCUCGGCUGUCACGGACUAUUGGCUCGUUCUGACCCUUGCACUAGUUCUUACAAACACACGGCCUCCCCCCGAUGAUCACCCGGUUUACAAAAAGGUGGUCUUCACUCUGUGCACGACUCGGUAUACGCAUGGAACCCGCCGCUUGUGCUUGUCUAGAACUGGCAUAUGUAUCCACGCGCUAACAUGCACCCCCUAUAGCACGCCUUUGAUCCCCUGUGGGGACGGUCCGUCAGAAAAAAUAGAUGGGGUUUGUCCGACAAUCGGGCGGCCGAGUUCCCACGAUGACUUUUGGUCCGCAAGACUUAUGCCUGCGUUAUCAAGUCGUGUGUUAUGCACAAUGCAGAUCACAUAUAACCUACACGUUAGCCGACAUCUUUGUGUCCUCAAGUUGCGGACCUGUGACGUCCGAGGUCCUCUAACUAGGGGUACUCCGGUGGCCUGGUCAGGCACCAGGGUCGGCCGGCACACACUCACUUCGCGCCACGACACACAAGGUGUCCCAGAAACAUGGCCCUCAAGGCGACUGACGCGUCCAUUUCAGGAUCAGCGUAUGUUUCUUCUUGAUCUAUUCUUACUCCCCCACCCGAAGAAGGUGUGUCUAUUACCCGGGCAAUUCUUUGCUAUCACGGCUUCACGUAAGUGCCGCUAUCGCCUUGUUCCGGUUGGGCGGUAUCACGGCACCAGAGGGAUACAUUCUUCGAUCCGGCCCUUGCUAGCGAGUACGACGGACAUAAGUGUUUUUAGAGAUAUGCGCCCGCCUACAGUAGGCCGCGACGCCGGAAGGCUCAUCCCGUUUGAGAGCACAGAGGCCAUUACAUCGCAAGUGCGGCUUAAAGCUAGCGUCGUGCUAGGCCCAAUGACCGCGCGGAGACACAUCAGAGAUGGCACUAAGUCCCAGAGCCAUUGCUCCAGUUCGGCGCCUGCGCGUCUAAGCUAUGUUACCAAGGUGGAAAUGUAUCCUCAAACGUGCCUUGGGCCUAACCAAGUCGAUGAGCAGGCAUUCGAUGAUUUCUGUUCCUACCCGAUUAUCAGCACGGUAGAUCAUAGAACGUUCACUAGAACGUUUGCUAAACUGCUGUCUGUUAGGUGGCUUUGCUGUACCGACAUGGAUCCGCCGGAUAGUCGUUCGGUGCAGCGCUUUAUGGCACGGUCUGCCCGGUGGCAAGCCGUAUCCCUUAUCAAUAGAUUGAACUCUGUCACUCCGCAAACGCUGGGGUCGUAG";
    std::ostringstream oss;

    for (std::string::size_type pos=0; pos<s.size(); pos += 3)
    {
        std::string const replacement = codons.find(s.substr(pos, 3))->second;
        if (replacement != "Stop")
        {
            oss << replacement;
        }
    }
    std::cout << oss.str();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P06_Finding_Pattern_In_DNA()
{
    std::string const s1 = "GGTTGGCGCTGCACTGAGGCGCTGGGCGCTGGGCGCTGCGGCGCTGCCCTTATGGCGCTGAGGGCGCTGGGCGCTGCCGGCGCTGGGCGCTGGCACGGCGCTGTCGGGCGCTGGGCGCTGGGCGCTGGGCGCTGCGGCGCTGAATGGCGCTGGGCGCTGGCTCCTAGTCGGCGCTGGGCGCTGCACCCACCGGGCGCTGTGGCGCTGATAGGCGCTGGAAGGCGCTGGATACGGCGCTGGGATCCTACGGCGCTGGGCGCTGGGCGCTGCCGGGCGCTGGGGCGCTGCTGGCGCTGTGATTGGCGCTGGGGCGCTGGCCGGGCGCTGTGGCGCTGGGCGCTGGGCGCTGTCAGTGCATTGTCGGCGCTGAGTACTTGGCGCTGTGGCGCTGGTCCGGCGCTGTGGCGCTGCAACCGGCGCTGGTTCGGCGCTGGGGCGCTGGGCGCTGGGTGCTACCAGGCGCTGATCGTGGTTTTGGCGCTGGGGCGCTGAACCGGGCGCTGGGCGCTGGGCGCTGTGGGGCGCTGGGCGCTGGGCGCTGACAGAGGCGCTGGGCGCTGGGCGCTGCTTCGGCGCTGCACTCTCGGCGCTGATGGCGCTGCCCATGCAGGGGCACGGCGCTGCAGGCGCTGGGCGCTGAGGCGCTGTGGCCGGGCGCTGCTAACGGCGCTGGGCGCTGTACGGCGCTGGGCGCTGGGCGCTGGGCGCTGCGGCGCTGGACGGCGCTGGGGCGCTGGGGCGCTGCAGCACGAAGGCGCTGTGGCGCTGTGTAGTCGAGGGCGCTGGGCGCTGGGGGCGCTGGAGGCGCTGGGGCGCTGCAGGGCGCTGAGGCGCTGTTACTAGGCGCTGGCGTTAGAAGGCGCTGATGGCGCTGGAATGGCGCTGGGCGCTGGGCGCTGTTAACGAATAAGGCGCTGAGAGTGGCGCTGCGGCGCTGCAGGCGCTGGGGCGCTGGGCGCTGTCGGGGCGCTGGGCGCTGGGGCGCTG";
    std::string const s2 = "GGCGCTGGG";

    std::string::size_type pos = s1.find(s2);
    while (pos != std::string::npos)
    {
        std::cout << (pos+1) << " ";
        pos = s1.find(s2, pos+1);
    }
    std::cout << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P07_Consensus_And_Profile()
{
    std::vector<std::string> const dataset =
        boost::assign::list_of
            ("TGTCAGTTATTACATACCTGCCGACTGGGCCGCGGTCGCCCGAGGCAGATGTTTAGAGTTCAAGTGCTGTCCCAGACCACAGGGTTAGACCGGGATCGTAATCTGCTTATCCTCATCATTTAAAGCGCAGGACCGACGCCGAGAACCAGTACTTTTAGCGTGTTCTAAAACTCTAAAATGTGCGGGAGTGAACACTTGAACATTGTTGAGTGCTGTTACCCGCCGTAGGCCCTGGACGCGTGACATGCCTGGCGGGATGTTGTCCGCAACTTGCGCACGAAGTGTTGCGGGGTTTCTGAGCATCGTCACACTCACTCTGCTCCGAACATCTACAACCTCTCACCCATCCTGGGCCCCTGCTGGCAGCATTTGTCCTTCCAGGCGTGTGGAGCGTATAAAAAACCGAGGGGAATGATCAAACTACGGGGATGGTACAGCGTTAGCCTGCACCCCAAGCTGATACGCGGTTTTCACGCTGTCGATGAAGTGGCTACGCACATAGAGTTGACTTCACCGCACAGCCAGCCAGTCCATACTTGCCTTGTATTTTAAGGGGTCAACCAAACAGGAGTAACTTATGCATGCTCGAGTGGTACTAACACGGACTGTTTCTACATGCTCTTAACACCGTCCAACTAGCTGACAGTTAGCTACTGGCTCCTCATTCCTCGTAACAAAACTACGTGTTCTCGACCTGCATGTCCGAATAGGTGTGTGCGTTAGATATGCTCCGTTGCGGCGCAAGTGTCACGATGCTGTGTGAGATTCCATGAGCGCCTTACGCTCTCAGAACAGTTGGAATAAATTCGTCCTGGAAAAGTATGCCAGCCAAATTTATTAGAAAGTTTATGTATATCGTACCCAACAGCAGGGATCGTACTACATTTTGCTACAGTCCAGGCGACGCGTTACGTAGATTC")
            ("TCTCCTTCGTCTGAGCTGTATTACTACACTCATTGCTGATAGGTCGATTCCCAGGCTTCATTGTCGAAGGTCATAACAAACTCGTCCAACCCGCTGTGCATCCTGATGAAGCCACTAACCATAGAGAAGGCAAGTGCCACATTGTGTAGTAGCAACGTTTTTGCGCAAAGAGTAGACACTGTTGGTAAGCGGGCCCTGTTGAGGGTCTGGTCTGTGACTAGCGATAGACTACAGTTAAATCAGTCGCACACAATCCCGGGCATGGTGTTTCGTGGAATCCTCAATAACAGCCGATATGTCATTTCGCGCGCACACTTCCCGGTATCATCCTAGGACACGGATTATCAGAGCGCGGAACGCATCCAAATGTACGCGTCCTCCTCAATTAGGGCAAGGAGCCCGCTTGTAAAGATTGCGCAAGGGACGAATATAGGGCGAATACTCCGGTTCTCGGGTTAATGTATGATGGTCCCCTGTCTCACGTTGACACGTGACATGAATCTGAGAGCAGCGCGTATAGCACCTCCGGTACAATGGTCACACGTGCTTTGCGTCGCTTGTAATTATTAATGACGCAGTTTCTCGGACAGAACAACCTCCCGGTGGTAGATCATGGGGGTCCTCGGCTTCATACTGTTTCACTATGGTGTCGTCAACACTATTCGACAAACACCCGCGAAAACGGATAGGTAGCCCGTATAAACGCTATCAGTGAGCAGATACCCGGGGATAATATAGCGACGCGCGGCGGCGAGGTCGTCGTCATAGTATTAGTTCCGGTTTACTGGGAAGTTTGATGACTACCCTGGCGGGCTTACCTGCACGAGCTTAGCCGCAGGAAGGTACGGTTTACGGGTGGGTCCTCAGGTGTGAAGGTTCTTTCCTGGGGCCATATTCTGACAGAAATCGTCGAGCTACGC")
            ("CGAAATTTGAATCTTTTGTGGAGCTTGATCCTGTATGGCCTTAAGTTGCTAAAAATAATGTGGGCATCACAAGGACCCGCAAGGCGGTCTTTCATCTCGCATTGGGTCGCGAAAGCTTTCCACCGTCCGACTTACAGTTGGAGTCCCCCCTAACAGGGCCGCCGTGGTCACGCCACCGCCTGTGTATCTATGCGAATGAGGACCTCACTGTGAGTCAATCAGATTCACGGCTGTCGGCCATTCTCATTGTATCCTTTCAACCTCATCCTCGGGCGAAACGTGTTTTGGGCAATTGGCGAGTCTTCATACCCCTTGTTACGTTCGGTGCTGAGAAAAGATGCCGCACGTTCGAGGGCTGCCTTCAATGCGCAGGAGGGGCCACGTGGTACGGTCTGCTGACCGGGATTTCCCCCCATGTCAAAACCTGGACGTCTTTCGTCGCTGCCTTAACAGCGATCACGGTGCGAGGCGAAATCAGGTAATTCTGATCCATGCGTACGATAGTGACCCGCTAGGCGCGATGCTGCAACATAGATGTGTGAACCAAATCACACGAGGTGAGCAGGCCGAACATTAAACCTGGAAGTGCCGTATCGTTTGTGAAGAGTTCTAGTCTGTCACCCAAATTGAGTACAGTGGTATTCATCCTCATACCTAGACAAAACCCAGTGAATGGGTGATGCGTGAGTTACAATCCTCCAGTTTTATAGCTACTGCGACCGCTTCTGAATGGGGCAAAATAGGAACTCCTACCAATGGATACCGTACGGGATCATTGTTCCTTTTAGCCACCTAGTAGGAATCTTCAATTATCCTCCCCGCGGAAAGAACGCAGCATTCACGTGAGCTCCCCCTTTCTAATGCCTCGCAGTCTAACTGCCCCGTGCAAATAAGTACAAATAAGCCGACCATCCTTCGTG")
            ("GGGTAAGAGTCGCTCAACTTAACAAGGCGACGTTGCGACCACCACTATTGAAGCTCCTTCGAGCTTAATGCAAGAGCTTCGCACCACGCGTACCCCAAAGCAGGCTCGCGGCTGGCCTCACCCGGGTTTCTTCATGTCCATTTCGCGATGAAATGTATGTGAAGCCCGGGAACGCCCGTCCCGGGAACATGAAAGGAGAGGGACTCAACTCTCTCGGGATTTTTCAGCAACCCCGTCTGTTTTCGAAGAGGACTGCCGGAGAGCCCGGCTCCAGGCCATGATTTTCGCTACGTGCGTTGTTGTCAATTATCTTGGCATTGCTTTTAGGAAACCGCGTGAGCATGAAGACAGCAGTGGGATCACACCATGACTTTGTGCTCACCCTGCAAGAACTTAAAAGCGCGTGTCACGCGCGTCTTTTCCAACTTGAGATCAGCTAGCCGTAAGACTTATCTCGGGATTTAGGTGGCGCTCAGGGCACGGATTAAATATACGTGCCTACGTTATAACCCTGAAACGTTTACTGGGCACTCCCGTATATGCATAAACCCACGATCATCTGCATTTACGCCATGCCCTGCTTGCGTCATTCGAGCGATGATTAGCGGTAGATTTATACAGCTGGCTGGAGGCCGTACACGCAATGTTATCTATCTTTGTCGTTAGCCGGACATGCGTTACCCTAAGGGACCCAACTCTACGTTATGGGTTTGACGACCAGCATGATGTTTCTTATTAAGCAGGTAGTTCAGTGGAATTAAGAACAGAGATGAGAGCCTGCATCTACTACACTCTGGTGACTCACTACTTAGTTAACAGGACGTTCTAGCACTGTAATGCAGTTGGACCCCAACAAGAGTGCCCCGCCATCAACGAGGTATAGCGTTATGCTAGCGAGCGAATGTGGCCGCGAAACACGC")
            ("GACTGTAACCTATGAAAAAACTTGCACCCTCTGTCCGCCCGGGTATTTATTATTGGCTCAAACATTTATACTCGTCGTCATGCGCGGCCCCACACCCACTTGTGGTGAGAGTATCATCGTGTTAATGGCGGCCGAGAAATTACGTCCAAACTCGCGCCCGATCGTCGATGAATTATAGTTGATGCTACTCTTGCACTCCGATTCGTTCATAGTTGTTCGGTAAGTAAACGGCCAAATCTGGGAATTCAAAGATGGTCACACACCCCAGCGATCGCATGGTATTAGCCATGTTCTCCAAAGGGTTGTCAACTTCATGGGACCAAAGTCGGAGAGGTCGTTAGCACTTGCTGAGCTGCGCGTGCTAGACTAGGCCAGCCAGTAGCCAGGCAACGCATCTATGGGCCGAACTCGCCTCAAGTTTACGACGCCGACTCTGCTAATTCCCGTTCTGTTAACAAGCAGCCTTTTTCAACCCGCGCCCCTGCGTATTGGAGGCTTCTGAATGATTGGAACCTAGTGCTCCTTGGTTCGACTAGGTCAATGGCCCAACGGCACCCACAGGTTATTTGTACGCGGGAAGTCGCTAACCCAATCTAAGCAGCCCCGTTGTGCCAAATCCATCACACACACTTTGGGGTTTCAGCCGCTGGTCTATCCCGGACTTGTAAGATGAAGGTTTAAGATCTGCATGGGGTTACCCGTTGAGGTTACCCGGTTAATTCCTTCGTACTGCATACAAACCGTACGGCGTCCCTTTGTAATGCCGCCCACCATGGTCTGTGTCTGAGACCCACGTATTGTCTCAATGACGATTATTGTCTTGAGAATGGGGGCAAAGTTTTTCCACATTTGGACTCCGAATGACTATCCGAAGTAACTAATCCGCAGTAGTCGTTAGTGGAAGTTGCCAACCAGATGAC")
            ("TCGAAGAAGACAACGACAGTCTAAGAGGCCCGCACAGCTCATCAAGTCTTGAACAGAAATTCACAACACTTTCAGGTGGTACGTGACTGGGTGGTATTGATGCGTTAACCAGCCCCGTCTCCCGTGAGAGTCACATTCTACGCTAGGTGCCAGGAAAGGCTGAGTCCTTGTGATCCAGTGACTCACTAAAACGTGGTGGGGGTATTGATTCCGCATGTCAAATGTTGTATCACCCCTTGGAACTGTTATGGTATGGCCGGGGTGCATCGGATCCCGGCGGGCGCAAAGCGAGAGCTAGGCAATTAGATACGGCTGGAAAAGGGCAATTAATCAGGTATTGAAAGCTTGTTACCCCCCCCCTCGCTACCTACGTCCGAGGAAGAACGTAGAGTCGTACTCGCGGATCTGTCGAATGCATGGCATTACTCATTAGTTATAGTGATGTCAGTGCTCTATGGCTAACGTTGGTACATCTAAGGCTTGTCTCCATCAAGCATTAGTCGAAGTCACAAAGGAGTTGTCGGTCAGGAGAGGCCTGTAGGATGCGAGTAGAGGGCATCTCTTTCTGGTGTAAATCCGGTAATCGTCCCTGCGGCGATCGTCGAAACAAGGTCACCACACAGGTTCCTCTTTCTCGATGACGGGACCGGGTTCCATTTTTTAGATGTGTCCTCTCAGACCGGCTCCTGAATTCATCGGGACAGAGCGGTTAGGTTTAGTCTAAGTCATGAAACGTCAACAACTTTCCCTCTATCCCTTGTCCCCTCAAGCCAGAGTTAAAAGGGTGAAACACTTAGGGCTGCACGGCTGATCCAGGCGATTACCTATCATACTTTGTTCGATTGGTCAGAGACGGTAGTCAGCCATTGGCAAGATAAAACCTTGTGATGGCCGTCGACGCGCAAATTGGGCCTGCCTAC")
            ("TCAGCGCCTGGACCAATCGAGACGGGGACGGGTATTCTTTAGACCAATCGGACATCCGATCGAATACGAGTCCATTTCGCTGCAGCCGGATGTGACTCTCGAAACTGTGAAGCCGGCTCGTTCAGATCAAGCCAGCCGGGGCCGGAATGTACCCGTAGCAACCCCGCTAGGCGGCGTCATACAGGGAGGTACCCCGCCGGGATCATGTTTCGTCGAACTCTAGCATCGTCCCAAAGATGGTTAGGGGAGGCGGCCTCATCGGCGAAGTTGCTTATTACAGATGGGCGGATAGATAAGGCAGGTTTCAGCGCCAACCTCAAGGATAGCCAACGCATACTGCTTCTTTCGCCGATCCTCGCTGAGATACAGCCCGTAGTCATGTCTAGCCTCGCCTCCTATCTTCAGCGCCATACGCTATCTTACAGGGTAGGATATTGGTCGCATGCCCCACTTTGAGGGCAACCTAAGGCGCTTTTGTCAGCATGATATCAAAGATGAGCAAGTAGATCTTTTGCCTAAGATAGGTAAGAAGCCCAGCGCTCGCCAGTCTATAGCGGAACGTGACAGAGCGAAAACAAAGTATTCGAAATTAGTTAGTTATGCAGCCATTCGCATAAAAATGGTTCGTGTTGCGCATATGGCGTGTAATGATACGGAAGTCGTTCTGCACTGCGCTGCTGCATAAAAGCCAGCCCTCCATTGAATTGATCGAACGCCGTCTATATACTTGCGCATGACCGACATTTTAGGGGCCTAGAATGCTAGCTGGTTCCAGGATATTGACCGCGGGTTGTTGCGCGGGTGCAGATATACCCTCGCCTGCGCGAGCCTTGTCGTAAACGCGCTTGACAAGAAAAAAGCACAGGCATCCGCAAAGATGGAGTCGCATCGGAGACATGCTTCGTACTTTCTATTCCAAC")
            ("GGGTCGTTAAGCCGTTCCTCGGCCTTTCAACTCTTAACTCGTTTTAAATCCTGGGGATGGCCTAGAGGGATTGACACCCGAGTTGGAATCTGCATACCGAAGGGCTGAGAGATGGTTATGGGTGACAAGAACGCTCTTCTTAGCGCCTAATGTCTGCCTATACTCCGACTCGCCAGACGCGGTATACTACGGGTGGTTCTCTTTGACCCAAAACTTCTAAGTAGCCGTCAAAGGCTTTTAGGCTCTGGACAGATACCCCGCCTTTGTAGTTATGACGTCTGTAACATAAGCATACCGCCATTTATTAGCCACTCCGTATAACAGCTTATTAGTTCACCACAGTAAAGAGTTACAACCTTAAGCGTTACAGGGGGATCGACGCATCAGGGTCTTGTAAGGTAATCCGCCCAGCACAAGGACCCAAAGGAGAGTTTATCAATTTCCTGCGCGATCCGTTACTCGCCCACGGCAACGTCATTTTTGTTTAGGATTGATCTTCAGCTAGAGTAGGAGGATTTTTTGAACCGTTGGCACCCTAAAGGCCGCGTTCCAATCAAAACCCGACTGCAATTATGTCCGTCACGTCACCGAAACGTACGTCCCGAGTCCTACATTTAGGTCAACACCTCTGTAGAAGCTGCTCATGTGATTCTACCGACTTACGGAATTTAAGACCTCCACTCATGATGTAATCGATAGCGCTTAAGGCCCCGCTGTAGGCCATCGGCGGTCACCTACGCTAACGAGGGAAGGTGAAATATTCCAGTATATGACTTTGCTTCTGTTGGCGCCAATGGGGCTCAGGCTCGATCAGCATGAGTAGTATATTTGTCTAGCACGATCCCAACTATTGAGGTACAGGCCCGGAGACATTTCTTTGGACAAGAGGGAGCAGATATCTATAAATTAAGCGAGAACTT")
            ("CCCATTCAATCTGCGTGTCGGGGCGCCTACTGTGTGTGGGCCATCGTACGTGAAATACAGTCACCCCTCGGCCCATGCATGGGGGCGACTCCAAACGAATGATTGTAACTGAGTGGACCCGTCGTGCGGGTATCCAAGGTGATATAAGTACTCCTTCCACCATGCCTGGGACACTGCTAGTAAAAAGGTCGTAGACCGCTACTTTGTGCCGGACCATGTCAGGCGATACGTCCAGGGCGACACGGGCGCTCGCTCTGTCTGTGGGTTTATCGAACATCATGCCATTTTGCGGCGTTTAGAGAGCGGAGTTTGACGTTATCTCGATCGCTTCTGCCCGCGACGGAATCACTGTGGGAGGATAAGTGGACGACCAGTAATAGATAGAAACTCAGCATACCCCATCACTATTCAGAGGTTAATTTGAGGACATATCAATACGACTTATGAACGAGTTCGAAATCGCATCGTCATCGTGATCCTGACACTAGAACCAGCCCCATATAACCACCATCCGGCTCTATCCTTTCTCCTCTATCTACTGGGTCGGTTAAAAGGTGGGCACCAATCTCTGAATGCTCGTAAAGGGGCAAAAATGCAACATGAGAGACATATAACCGTAGGGGGCTTCTTATAACCTCTGAACCAGAGAACTACTTTACCTCCATACGATACACCCGTTCGCTCTCTGTCGGACTTCTGGTTTAGGACAGGAGCTTCGAAGCTATTGGAGCACTGACTCTTCGCGCGAAAGTCGACGCTTATATATTCCACTCCATACCCGATTGACACTCAACATACTAGTTTATGTGAGCCACTATGACGCGTTATGTTGAAAGGTACTTATGCGGGTTTATATCTCGGACAGCGCGACCTAATCATTACAATTCAGACGTGAAATGTTAATTCATCTGGTCGAGCAG")
            ("AATGCATCGACAGAACCACGGAAAGCATGTGCAAAGAGTCCATGGTCCAATTCTTCATGTTGCGGTGATCTATTGAGTGCTATGAGGGTGATGAAAACCTATCGCGGAGCCTTCTGAAAGCACCACATCCGACTCGAACGCCGTGCGCATATATGGCGCTCGTGCCTCGAGGCGTCGGACCGTCTGGCACCAGCGTTTGTAATGACGCAAGGAGGTCAGGCGGTCACGGCAATCCGAGTATCTACTCCCAGGTTACTAGCTCAATGATCCGCTGCACGTAATCTCAGCTATTCGCATAGTTAGATTAACTAGGTCTGGTGAGCCACTAATACAGTCAATTCTCTCATTCGTGCAGGTGTAGTACTTCATAAACCTGGTACGTACAAGGGCTGGGCGAATTGCATATCCGTTGAGAATTTTAAAAGTGAACTCGGAGTCACTCTTCAACACCGGATTCCCATTACTGCCGGTTGCAACACGATTGCGCCTGACCGTGCATCCTGGCACATGTTGGGAACAACATTACCTCATGCCCACGAGGCCGCGGCTGGCTGCGGTATGGCCCTGAGCAGCCAATCTAGTGCTCATACGCCGGTCATTTAGGGCTAATGAGCGGGCGCTGCGATATGTAGACGCAGTCGGCGTTAGACCTCGCATTCTAGTGAACTGTCCTAAAACCCTCCATATTTGAGGTGACGTCGTGCTACTCACGGGTGCGGCGTTAATAAATGTCCAGCATAATCAAGAGAGTATCATTTGATACTATCCTTGACTGTTCTTAATATTTTCCACTACCGCTAAGGTGTGTCCAGGGGGTTTACGTATTAGACTCAGGTCATGGAAGGAAAAGACGCTAAACGATGCATGCCATCCCACTGCTTACCGTGGAATCCTGCTGTTATACGTACCTGGTGTGGAAA");

    typedef std::map<char, std::vector<std::size_t> > Profile;
    Profile profile;
    profile['A'].resize(dataset[0].size());
    profile['C'].resize(dataset[0].size());
    profile['G'].resize(dataset[0].size());
    profile['T'].resize(dataset[0].size());

    for (std::vector<std::string>::const_iterator itr=dataset.begin(); itr!=dataset.end(); ++itr)
    {
        std::string const& s = *itr;
        assert(s.size() == dataset[0].size());
        for (std::size_t i=0; i!=s.size(); ++i)
        {
            ++profile[s[i]][i];
        }
    }

    for (std::size_t i=0; i!=dataset[0].size(); ++i)
    {
        std::size_t const a = profile['A'][i];
        std::size_t const c = profile['C'][i];
        std::size_t const g = profile['G'][i];
        std::size_t const t = profile['T'][i];

        if      (a >= a && a >= c && a >= g && a >= t) { std::cout << 'A'; }
        else if (c >= a && c >= c && c >= g && c >= t) { std::cout << 'C'; }
        else if (g >= a && g >= c && g >= g && g >= t) { std::cout << 'G'; }
        else if (t >= a && t >= c && t >= g && t >= t) { std::cout << 'T'; }
    }
    std::cout << std::endl;

    for (Profile::const_iterator itr=profile.begin(); itr!=profile.end(); ++itr)
    {
        std::cout << itr->first << ": ";
        for (std::vector<std::size_t>::const_iterator itr2=itr->second.begin(); itr2!=itr->second.end(); ++itr2)
        {
            std::cout << *itr2 << " ";
        }
        std::cout << "\n";
    }
    std::cout << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P08_GC_Content()
{
    Sequences sequences = GetFasta("input.txt");

    std::string max_name;
    double max_value = 0.0;

    for (std::map<std::string, std::string>::const_iterator itr=sequences.begin(); itr!=sequences.end(); ++itr)
    {
        long cg_count = 0;
        for (std::string::const_iterator itr2=itr->second.begin(); itr2!=itr->second.end(); ++itr2)
        {
            if (*itr2 == 'C' || *itr2 == 'G')
            {
                ++cg_count;
            }
        }

        double value = static_cast<double>(cg_count) / static_cast<double>(itr->second.size()) * 100.0;
        if (value > max_value)
        {
            max_value = value;
            max_name = itr->first;
        }
    }

    std::ofstream output("output.txt");
    output << max_name << "\n" << std::fixed << std::setprecision(2) << max_value << "%" << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P09_Overlap_Graphs()
{
    Sequences sequences = GetFasta("input.txt");
    std::ofstream output("output.txt", std::ios::trunc);

    for (Sequences::const_iterator itr1=sequences.begin(); itr1!=sequences.end(); ++itr1)
    {
        for (Sequences::const_iterator itr2=sequences.begin(); itr2!=sequences.end(); ++itr2)
        {
            if (itr1->first != itr2->first)
            {
                std::string const itr1_suffix = itr1->second.substr(itr1->second.size() - 3);
                std::string const itr2_prefix = itr2->second.substr(0, 3);
                if (itr1_suffix == itr2_prefix)
                {
                    output << itr1->first << " " << itr2->first << std::endl;
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P10_Finding_A_Shared_Motif()
{
    std::ifstream input("input.txt");
    std::vector<std::string> sequences((std::istream_iterator<std::string>(input)), std::istream_iterator<std::string>());

    std::set<std::string> substrings;

    // get all substrings of the first two sequences
    for (std::string::const_iterator i=sequences[0].begin(); i!=sequences[0].end(); ++i)
    {
        for (std::string::const_iterator j=sequences[1].begin(); j!=sequences[1].end(); ++j)
        {
            std::string current;
            std::string::const_iterator p1 = i;
            std::string::const_iterator p2 = j;

            while (p1 != sequences[0].end() && p2 != sequences[1].end())
            {
                if (*p1 != *p2)
                {
                    current.clear();
                }
                else
                {
                    current += *p1;
                    if (current.size() > 4)
                    {
                        substrings.insert(current);
                    }
                }
                ++p1, ++p2;
            }
        }
    }
    for (std::string::const_iterator i=sequences[1].begin(); i!=sequences[1].end(); ++i)
    {
        for (std::string::const_iterator j=sequences[0].begin(); j!=sequences[0].end(); ++j)
        {
            std::string current;
            std::string::const_iterator p1 = i;
            std::string::const_iterator p2 = j;

            while (p1 != sequences[1].end() && p2 != sequences[0].end())
            {
                if (*p1 != *p2)
                {
                    current.clear();
                }
                else
                {
                    current += *p1;
                    if (current.size() > 4)
                    {
                        substrings.insert(current);
                    }
                }
                ++p1, ++p2;
            }
        }
    }

    // sort the subsequences by size
    std::multimap<std::size_t, std::string> subs;
    for (std::set<std::string>::const_iterator itr=substrings.begin(); itr!=substrings.end(); ++itr)
    {
        subs.insert(std::make_pair(itr->size(), *itr));
    }

    // now starting from the largest subsequences, try to find one that exists in all remaining sequences
    for (std::multimap<std::size_t, std::string>::const_reverse_iterator itr=subs.rbegin(); itr!=subs.rend(); ++itr)
    {
        bool exists = true;
        for (std::vector<std::string>::const_iterator itr2=sequences.begin(); exists && itr2!=sequences.end(); ++itr2)
        {
            if (itr2->find(itr->second) == std::string::npos)
            {
                exists = false;
            }
        }

        if (exists)
        {
            std::cout << itr->second << std::endl;
            return;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P11_Inferring_mRNA_from_Protein()
{
    std::map<char, unsigned long long> codons = 
        boost::assign::map_list_of
        ('A', 4)    ('C', 2)    ('D', 2)    ('E', 2)
        ('F', 2)    ('G', 4)    ('H', 2)    ('I', 3)
        ('K', 2)    ('L', 6)    ('M', 1)    ('N', 2)
        ('P', 4)    ('Q', 2)    ('R', 6)    ('S', 6)    
        ('T', 4)    ('V', 4)    ('W', 1)    ('Y', 2);

    std::size_t two = 0;
    std::size_t three = 1;
    std::string const s = "MHLHMITNLMSEESTILGPRYYVRWINFECICNDMGWMHLCILVDKW";
    for (std::string::const_iterator itr=s.begin(); itr!=s.end(); ++itr)
    {
        switch (codons[*itr])
        {
        case 2: ++two; break;
        case 3: ++three; break;
        case 4: two += 2; break;
        case 6: ++two; ++three; break;
        }
    }
    std::cout << "2^" << two << " x 3^" << three << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P12_Open_Reading_Frames()
{
    std::string const input = "TACCGTCTCCGCGCTACGATTAGAGTGAGTGCGGCCTAAATGGAGGTCTCACACAGTAATTCGACTGCGCAGTGCGAAGGACACAACAGCGAACGGTCTGCGCCCCAGAGGACTTTAGTAGTTTCCTCACCGAGATCCAAGTAGTAACGTCTGAAACTAGTAAACGTGCGGACTACCCGCCCCCCTGGTTTGTCTGAACAGCGAACCGTACTTTACAATTCCGCCTAGTCTATAATATAGCTCTATGAAAAAAATACATCATCCGGTTTTGGGTCTCACGACAAGATACCTCCGCAAAGGCATCGTTGCCTCAAGATTAGGCACCTACGGGCTTATCGTTAGGGATGCGTGGACGTCCGTGTAGCGCTGAGTCCATGATGCCACCTTGTGGGGTCGACGCGGATAAATGTTTGGACCACTGACATAGTTCGCGTCGTAGCTACGACGCGAACTATGTCAGTGGTCCAAACATACGCGTTGCGCGGAGTTTTCCTGAGCGTCATGCTATCCATAGGACCGTAACCTGTATGATTAATAGTACGGCATCAGTGCGGTCACTATGTGGATCCAGTGCTACCCCATTCCTTCCTTTTCCCTCCCCTGCAAGCCTGGGAGTAGGGACGACCCCTAATGATGAAAAGCCCCGCAGTATTTTGCAGAGGCCCACAGTCCAAGCTACGCACAATTCGATTTAGGCCAAAGCACCCGCTTTTAGGGATATTGCTTCATTCGGTCACCCATCGGAGGCGTTGAAAGTGGTAATATGATTTCCATATGATTCGACTAAGGACCATCCCTTCAAAAGTCAGCCCGGCGAGAAGCAGTGTGGTCGTACAACGAGGAGACGAGTGCAGACAACTTAACCCTATTATTAGCTG";

    std::string const rna1 = ToRna(input);
    std::string const rna2 = ToRna(ReverseComplement(input));
    std::cout << "RNA 1:  " << rna1 << "\nRNA 2:  " << rna2 << "\n\n" << std::endl;

    std::set<std::string> orf;

    std::string::size_type pos = rna1.find("AUG");
    while (pos != std::string::npos)
    {
        std::string current = "M";
        std::string::size_type tmp = pos;
        while (true)
        {
            tmp += 3;
            if (tmp >= rna1.size() || codons.count(rna1.substr(tmp, 3)) == 0)
            {
                break;
            }

            std::string const codon = codons.find(rna1.substr(tmp, 3))->second;
            if (codon == "Stop")
            {
                orf.insert(current);
                break;
            }
            else
            {
                current += codon;
            }
        }

        // and find the next start position
        pos = rna1.find("AUG", pos + 1);
    }

    pos = rna2.find("AUG");
    while (pos != std::string::npos)
    {
        std::string current = "M";
        std::string::size_type tmp = pos;
        while (true)
        {
            tmp += 3;
            if (tmp >= rna2.size() || codons.count(rna2.substr(tmp, 3)) == 0)
            {
                break;
            }

            std::string const codon = codons.find(rna2.substr(tmp, 3))->second;
            if (codon == "Stop")
            {
                orf.insert(current);
                break;
            }
            else
            {
                current += codon;
            }
        }

        // and find the next start position
        pos = rna2.find("AUG", pos + 1);
    }

    for (std::set<std::string>::const_iterator itr=orf.begin(); itr!=orf.end(); ++itr)
    {
        std::cout << *itr << std::endl;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P13_Enumerating_Gene_Orders()
{
    int n = 6;
    
    std::vector<int> v;
    for (int i=1; i<=n; ++i) { v.push_back(i); }

    int factorial = 1;
    while (n)
    {
        factorial *= n--;
    }
    std::cout << factorial << "\n";
    

    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));
    std::cout << "\n";

    while (std::next_permutation(v.begin(), v.end()))
    {
        std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));
        std::cout << "\n";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P14_Calculating_Protein_Mass()
{
    std::string const s = "HGTWAGLSSYNHDHAVSPDYTNMWLWHARQEEDILNSFMHYKNIIRFPKREYEKLRVPARGHWNVSLGWDHVVTHEDLDYNQMCKQLVDKAIAIVAGNCDVGNDADSYIDYRASQAPFEDIRQNNPYWDLWKIDPVPNCMRSPQTIPMNDITCWYIYKIDMPAVAREMMIDEYHDGLMNPHHQQQLYYFLKQFSRAYQGCQPAQKNIQRSSDSHPSRCPGVIAQCWQGNAVGIWASRHIKEHFDAFIACMEVTGSQMDAQCTPAFMQPLFIWYGVFAVTQDFEGPWNCSWPMNKGYPRRFYAYSEEELAKTKFEFLISVQEWGGFLVGRQNIESHKSVQIHLIVNNWFRAHHYFENKMIWHTNSFHSYFSLYVHEESVILMAMDPVEKSFHHYKARYTQMSSMRAADLRFTKYPEKHGDQFANDQNSQNLWTSSPKQEGYWLDRGTEIMNFCFIPSLMFLHRQAYYEKNATMDDFSMCFTKHFGTMCDRNQIMYSSDQKQIWRHCSMVWDHKPFKHIVTHRFWVRPWLKLSDREIWLDQTPTLQEWWFVYAITYCPHIWVGIFDSCRTTNWATYRHTSPTVSQLTPWGRDKVMRFCESRNIVELNEALGITQWCQWQIQGFQIMKHDSDGCYYCLVTHNDVVFIGYCETNFNRSFETPAVGSNTDNWRVRMRWEAFEKFPAEPSKIEVDSMLVKQKGNHRELTWAFKYNHMPRWLNMMYRYYVYEFKHAGHWIWARFQNAKVQTAVKPWIGDCHRNTVRYQSHEWLHTFCRINLMVIQCDETFRAMYKMKDKDKSRMNNGQVNSKVFHYISPSFQVYDTTVSNWINLVGAVWGIPEPGCCKAAAELYDCQWLTWDICWKSPDGHSRRMMCTKWAVPYEYYAKGVYCSQFPGFRIVGMRINLPLAEWIVVSVKFNAPANQEL";

    double sum = 0.0;
    for (std::string::const_iterator itr=s.begin(); itr!=s.end(); ++itr)
    {
        sum += masses.find(*itr)->second;
    }
    std::cout << std::fixed << std::setprecision(2) << sum << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P15_Locating_Restriction_Sites()
{
    std::string const s = "CGAGAGAGGGCAAAGTAGGCCGAGAGGGCACAGTTTAAACTCAGGGGCAAAGGGAAGTTGAAGCCTATCACGAGACGTATTGGTCCCGCCTAGTTCGATGGATGATCGCTGGCCAAGCTCAAGACCTAGGGACGTCGCACTTGTCAGGATGAAAAAAAATAATGTTCAACGACGACGTAAGCATGGAGCCTCCCTAATCATGCCGTTACGTTGCAGACCAACATCCATATAAACGGCTGCTCAATGGATGCATATCCGATACCATACACGTCTCGACCCTACGACCCGAGAGCTGTAAAGATCCTACGCTTCACGAAGTCCGCCGAGCAAGCTGACTGGCGGTTTGGATGACCTGACACCCCTTTGGGGCGCCGGGATACTCTTCAGTGCTATAAGTTGTGAAGCCGACTCATAACACACTGGCCGGGGACCCTCCATTGTAGGTCAGGCTGGCCACCCGATTGCAACAGTGAGAGTGTTCACAAATAGACGAATCCATAGCGCGATGCCTACCCAAAGCTGCGGCCGAACCGTGATGGAGCGACGATAGTTCACGGCTTAGGAAATACTCGTACTGGACCCGCTGCCGAACAACGGCAGGGATCGGCAGACGCGTTACTATTTTTCCGGGGTGCAGAATGAGCGTGTTAGAACTCCTATCTGTCAACTGGGGTTTTTACCCCATCCGTGGTGTGCCCTCGTCGGTAGAACCAGACGGGGGGATCTAAAGTATAATTTCCGGTGAGAAAGTCAGGATTTGGCTCACTCCGTTTGCTTACGGTAAAGTCGCGTTGGAATATTTTACAGGTACTTACGTAGGAACTCCACATTATTGTTGCTTCTTCTGACTACTGTGTTTTTTGGAACACTCCACGTACGCGTGATCTGGCCCCGTACTATGCAATA";
    std::string u = ReverseComplement(s);
    std::reverse(u.begin(), u.end());
    
    for (std::string::size_type pos= 0; pos<s.size(); ++pos)
    {
        if (pos <= (s.size() - 4)) { if (u.substr(pos, 4) == reverse(s.substr(pos, 4))) { std::cout << (pos + 1) << " " << 4 << "\n"; } }
        if (pos <= (s.size() - 5)) { if (u.substr(pos, 5) == reverse(s.substr(pos, 5))) { std::cout << (pos + 1) << " " << 5 << "\n"; } }
        if (pos <= (s.size() - 6)) { if (u.substr(pos, 6) == reverse(s.substr(pos, 6))) { std::cout << (pos + 1) << " " << 6 << "\n"; } }
        if (pos <= (s.size() - 7)) { if (u.substr(pos, 7) == reverse(s.substr(pos, 7))) { std::cout << (pos + 1) << " " << 7 << "\n"; } }
        if (pos <= (s.size() - 8)) { if (u.substr(pos, 8) == reverse(s.substr(pos, 8))) { std::cout << (pos + 1) << " " << 8 << "\n"; } }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P16_RNA_Splicing()
{
    std::ifstream input("input.txt");
    std::vector<std::string> lines((std::istream_iterator<std::string>(input)), std::istream_iterator<std::string>());

    std::string s = lines[0];

    std::vector<std::string> introns;
    for (std::size_t i=1; i!=lines.size(); ++i)
    {
        if (!lines[i].empty())
        {
            introns.push_back(lines[i]);
        }
    }

    for (std::vector<std::string>::const_iterator itr=introns.begin(); itr!=introns.end(); ++itr)
    {
        boost::replace_all(s, *itr, "");
    }

    std::string const t = ToRna(s);
    for (std::string::size_type pos=0; pos<t.size(); pos += 3)
    {
        std::string const codon = codons.find(t.substr(pos, 3))->second;
        if (codon != "Stop")
        {
            std::cout << codon;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P17_Speeding_Up_Motif_Finding()
{    
    std::ifstream input("input.txt");
    std::string s;
    std::getline(input, s);

    //s = "CAGCTCAGCA";
    std::vector<int> p(s.size());

    std::ofstream output("output.txt");
    output << "0 " << std::flush;

    int p1 = 0;
    for (int i=1; i!=p.size(); ++i)
    {
        if (s[i] == s[p1])
        {
            p[i] = p[i-1] + 1;
            ++p1;
        }
        else
        {
            while (true)
            {
                if (s.substr(0, p1) == s.substr(i-p1+1, p1))
                {
                    // this is guaranteed to bail out when p1 reaches zero
                    p[i] = p1;
                    break;
                }
                --p1;
            }

        }
        output << p[i] << " " << std::flush;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P18_Enumerating_Kmers_Lexicographically()
{
    char const a[] = "ALSDX";
    char const* a_end = a + sizeof(a) - 1;
    std::size_t const n = 4;

    std::ofstream output("output.txt", std::ios::trunc);

    char b[100] = {0};
    for (char const* i0=a; i0!=a_end; ++i0)
    {
        b[0] = *i0;
        if (n==1) { output << b << "\n"; }
        else
        {
            for (char const* i1=a; i1!=a_end; ++i1)
            {
                b[1] = *i1;
                if (n==2) { output << b << "\n"; }
                else
                {
                    for (char const* i2=a; i2!=a_end; ++i2)
                    {
                        b[2] = *i2;
                        if (n==3) { output << b << "\n"; }
                        else
                        {
                            for (char const* i3=a; i3!=a_end; ++i3)
                            {
                                b[3] = *i3;
                                if (n==4) { output << b << "\n"; }
                                else
                                {
                                    for (char const* i4=a; i4!=a_end; ++i4)
                                    {
                                        b[4] = *i4;
                                        if (n==5) { output << b << "\n"; }
                                        else
                                        {
                                            for (char const* i5=a; i5!=a_end; ++i5)
                                            {
                                                b[5] = *i5;
                                                if (n==6) { output << b << "\n"; }
                                                else
                                                {
                                                    for (char const* i6=a; i6!=a_end; ++i6)
                                                    {
                                                        b[6] = *i6;
                                                        if (n==7) { output << b << "\n"; }
                                                        else
                                                        {
                                                            for (char const* i7=a; i7!=a_end; ++i7)
                                                            {
                                                                b[7] = *i7;
                                                                if (n==8) { output << b << "\n"; }
                                                                else
                                                                {
                                                                    for (char const* i8=a; i8!=a_end; ++i8)
                                                                    {
                                                                        b[8] = *i8;
                                                                        if (n==9) { output << b << "\n"; }
                                                                        else
                                                                        {
                                                                            for (char const* i9=a; i9!=a_end; ++i9)
                                                                            {
                                                                                b[9] = *i9;
                                                                                if (n==10) { output << b << "\n"; }
                                                                                else
                                                                                {
                                                                                    assert(false);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool P19_recurse(std::set<std::string>& sequences, std::deque<std::string>& ordered, std::ostream& output, bool find_chain, std::size_t& chain_length)
{
    if (find_chain)
    {
        chain_length = ordered.size();
    }

    if (sequences.empty())
    {
        //we have a solution
        for (std::size_t i=0; i!=(ordered.size() - 1); ++i)
        {
            std::string const m = ordered[i+1].substr(0, ordered[i+1].size() / 2);
            std::string::size_type pos = ordered[i].find(m);
            assert(pos != std::string::npos);
            output << ordered[i].substr(0, pos);
        }
        output << ordered[ordered.size() - 1];
        return true;
    }

    {
        std::set<std::string> front_matches;
        std::string const m = ordered.front().substr(0, ordered.front().size() / 2);
        for (std::set<std::string>::const_iterator itr=sequences.begin(); itr!=sequences.end(); ++itr)
        {            
            if (itr->find(m) != std::string::npos)
            {
                front_matches.insert(*itr);
            }
        }
        if (!find_chain || front_matches.size() == 1)
        {
            for (std::set<std::string>::const_iterator itr2=front_matches.begin(); itr2!=front_matches.end(); ++itr2)
            {
                sequences.erase(*itr2);
                ordered.push_front(*itr2);
                if (P19_recurse(sequences, ordered, output, find_chain, chain_length)) { return true; }
                ordered.pop_front();
                sequences.insert(*itr2);
            }
        }
    }

    {
        std::set<std::string> back_matches;
        std::string const m = ordered.back().substr(ordered.back().size() / 2);
        for (std::set<std::string>::const_iterator itr=sequences.begin(); itr!=sequences.end(); ++itr)
        {            
            if (itr->find(m) != std::string::npos)
            {
                back_matches.insert(*itr);
            }
        }
        if (!find_chain || back_matches.size() == 1)
        {
            for (std::set<std::string>::const_iterator itr2=back_matches.begin(); itr2!=back_matches.end(); ++itr2)
            {
                sequences.erase(*itr2);
                ordered.push_back(*itr2);
                if (P19_recurse(sequences, ordered, output, find_chain, chain_length)) { return true; }
                ordered.pop_back();
                sequences.insert(*itr2);
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P19_Genome_Assembly_As_Shortest_Substring()
{
    std::ifstream input("input.txt");
    std::set<std::string> sequences((std::istream_iterator<std::string>(input)), std::istream_iterator<std::string>());
    std::ofstream output("output.txt", std::ios::trunc);

    std::deque<std::string> ordered;

    //find the best starting element
    std::string best_starting_point;
    std::size_t best_length = 0;
    for (std::set<std::string>::const_iterator itr=sequences.begin(); itr!=sequences.end(); ++itr)
    {
        ordered.clear();
        ordered.push_back(*itr);
        std::set<std::string> copy = sequences;
        copy.erase(*itr);
        std::size_t chain_length = 0;
        P19_recurse(copy, ordered, output, true, chain_length);
        if (chain_length > best_length)
        {
            best_length = chain_length;
            best_starting_point = *itr;
        }
    }

    ordered.clear();
    ordered.push_back(best_starting_point);
    sequences.erase(best_starting_point);
    std::size_t dummy = 0;
    P19_recurse(sequences, ordered, output, false, dummy);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool P19_recurse2(Matches const& matches, std::vector<std::string>& ordered, std::set<std::string>& used, std::ostream& output, std::size_t& max)
{
    if (ordered.size() == matches.size())
    {
        //we have a solution
        for (std::size_t i=0; i!=(ordered.size() - 1); ++i)
        {
            std::string const m = ordered[i+1].substr(0, ordered[i+1].size() / 2);
            std::string::size_type pos = ordered[i].find(m);
            assert(pos != std::string::npos);
            output << ordered[i].substr(0, pos);
        }
        output << ordered[ordered.size() - 1];
        return true;
    }
    if (ordered.size() > max)
    {
        max = ordered.size();
        std::cout << "max: " << max << std::endl;
    }
    
    std::string const& tail = ordered.back();
    Matches::const_iterator tail_itr = matches.find(tail);
    assert(tail_itr != matches.end());
        
    for (std::set<std::string>::const_iterator itr=tail_itr->second.second.begin(); itr!=tail_itr->second.second.end(); ++itr)
    {
        std::string const& s = *itr;
        if (used.count(s) == 0)
        {
            ordered.push_back(s);
            used.insert(s);
            if (P19_recurse2(matches, ordered, used, output, max)) { return true; }
            used.erase(s);
            ordered.pop_back();
        }
    }
    return false;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P19_Genome_Assembly_As_Shortest_Substring_2()
{
    std::ifstream input("input.txt");
    std::vector<std::string> sequences((std::istream_iterator<std::string>(input)), std::istream_iterator<std::string>());
    std::ofstream output("output.txt", std::ios::trunc);

    Matches matches;

    for (std::size_t i=0; i!=sequences.size(); ++i)
    {
        for (std::size_t j=0; j!=sequences.size(); ++j)
        {
            if (i != j)
            {
                std::string const& s1 = sequences[i];
                std::string const& s2 = sequences[j];
                if (s1.find(s2.substr(0, (s2.size() / 2) + 1)) != std::string::npos) 
                {   
                    matches[s1].second.insert(s2);
                    matches[s2].first.insert(s1);
                }
            }
        }
    }

    std::string first, last;
    for (Matches::const_iterator itr=matches.begin(); itr!=matches.end(); ++itr)
    {
        if (itr->second.first.empty()) { assert(first.empty()); first = itr->first; }
        if (itr->second.second.empty()) { assert(last.empty()); last = itr->first; }
    }
    assert(!first.empty() && !last.empty());
    int i=0;

    std::set<std::string> used;
    std::vector<std::string> ordered;
    ordered.push_back(first);
    used.insert(first);

    std::size_t max = 0;
    for (std::set<std::string>::const_iterator itr=matches[first].second.begin(); itr!=matches[first].second.end(); ++itr)
    {
        std::cout << "starting " << ++i << " of " << matches[first].second.size() << std::endl;
        ordered.push_back(*itr);
        used.insert(*itr);
        if (P19_recurse2(matches, ordered, used, output, max)) { std::cout << "solution found" << std::endl; return; }
        used.erase(*itr);
        ordered.pop_back();
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P20_BuildTable()
{
    return;

    typedef std::vector<char> Sequence;
    typedef std::map<Sequence, int> Table;
    Table table;

    int distance = 0;
    Sequence start = boost::assign::list_of('0')('1')('2')('3')('4')('5')('6')('7')('8')('9');
    table[start] = distance;

    int new_entries = 1;
    while (new_entries)
    {
        new_entries = 0;
        for (Table::iterator itr=table.begin(); itr!=table.end(); ++itr)
        {
            if (itr->second == distance)
            {
                Sequence s = itr->first;
                for (Sequence::iterator p1=s.begin(); p1!=(s.end()-1); ++p1)
                {
                    for (Sequence::iterator p2=p1+1; p2!=s.end(); ++p2)
                    {
                        std::reverse(p1, p2+1);
                        if (table.insert(std::make_pair(s, distance + 1)).second)
                        {
                            //insertion succeeded
                            ++new_entries;
                        }
                        std::reverse(p1, p2+1);
                    }
                }
            }
        }
        ++distance;
    }

    std::cout << "table built" << std::endl;

    std::ofstream file("table.txt", std::ios::trunc);
    for (Table::const_iterator itr=table.begin(); itr!=table.end(); ++itr)
    {
        file.write(&itr->first[0], 10);
        file << " " << static_cast<char>(itr->second + '0') << "\n";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void P20_Reversal_Distance()
{
    // load in table
    typedef std::map<long long, int> Table;
    Table table;

    std::cout << "loading table" << std::endl;
    std::ifstream ftable("table.txt");
    while (!ftable.eof())
    {
        long long a;
        int b;
        ftable >> a >> b;
        table[a] = b;
    }
    assert(table.size() == 3628800);
    std::cout << "finished loading table" << std::endl;

    // load the input   
    std::ifstream input("input.txt");
    std::string line;

    while (true)
    {
        // read first set of numbers
        std::vector<long long> v1(10);
        input >> v1[0] >> v1[1] >> v1[2] >> v1[3] >> v1[4] >> v1[5] >> v1[6] >> v1[7] >> v1[8] >> v1[9];
        --v1[0]; --v1[1]; --v1[2]; --v1[3]; --v1[4]; --v1[5]; --v1[6]; --v1[7]; --v1[8]; --v1[9]; 

        // read second set of numbers
        std::vector<long long> v2(10);
        input >> v2[0] >> v2[1] >> v2[2] >> v2[3] >> v2[4] >> v2[5] >> v2[6] >> v2[7] >> v2[8] >> v2[9];
        --v2[0]; --v2[1]; --v2[2]; --v2[3]; --v2[4]; --v2[5]; --v2[6]; --v2[7]; --v2[8]; --v2[9]; 
        
        if (input.eof())
        {
            break;
        }

        std::vector<long long> v3(10);
        for (long long i=0; i!=10; ++i)
        {
            long long x = v1[static_cast<unsigned int>(i)];
            std::vector<long long>::iterator itr = std::find(v2.begin(), v2.end(), x);
            v3[std::distance(v2.begin(), itr)] = i;
        }

        // convert v3 to a number
        long long num = (((((((((v3[0])*10+v3[1])*10+v3[2])*10+v3[3])*10+v3[4])*10+v3[5])*10+v3[6])*10+v3[7])*10+v3[8])*10+v3[9];

        // and look up the answer
        std::cout << table[num] << " ";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void PROB_Introduction_To_Probability()
{
    std::string const s = "0.000 0.059 0.133 0.183 0.221 0.284 0.323 0.374 0.450 0.479 0.547 0.554 0.639 0.654 0.742 0.767 0.845 0.893 0.945 1.000";
    std::istringstream iss(s);

    while (!iss.eof())
    {
        double d;
        iss >> d;
        
        double pC = d / 2.0;
        double pG = d / 2.0;
        double pA = (1.0 - d) / 2.0;
        double pT = (1.0 - d) / 2.0;

        double x = pA*pA + pC*pC + pG*pG + pT*pT;
        //double xx = d*d-d+0.5;
        //assert(x == xx);
        std::cout << std::fixed << std::setprecision(3) << x << " ";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void SIGN_Enumerating_Oriented_Gene_Orderings()
{
    int const n = 6;
    int const upper = (1<<n);

    int factorial = 1;
    std::vector<int> v;
    for (int i=1; i<=n; ++i) { v.push_back(i); factorial *= i; }

    std::ofstream output("output.txt", std::ios::trunc);
    output << (upper*factorial) << "\n";
    
    int rows = 0;
    do
    {
        for (int i=0; i<upper; ++i)
        {
            for (int j=0; j!=v.size(); ++j)
            {
                bool const negate = (i >> j) & 0x1;
                output << (v[j] * (negate ? -1 : 1)) << " ";
            }
            output << "\n";
            ++rows;
        }
    }
    while (std::next_permutation(v.begin(), v.end()));
     assert(rows == upper*factorial);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void SSEQ_Finding_A_Spliced_Motif()
{
    std::ifstream input("input.txt");
    std::string s1, s2;
    input >> s1 >> s2;

    std::string::size_type pos = 0;
    for (std::string::const_iterator itr=s2.begin(); itr!=s2.end(); ++itr)
    {
        pos = s1.find(*itr, pos + 1);
        std::cout << (pos+1) << " ";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void TREE_Completing_A_Tree()
{
    std::ifstream input("input.txt");
    int nodes;
    input >> nodes;

    typedef std::vector<std::set<int> > BranchList;
    BranchList branches;

    for (int i=1; i<=nodes; ++i)
    {
        branches.push_back(std::set<int>());
        branches.back().insert(i);
    }

    while (!input.eof())
    {
        int x=0, y=0;
        input >> x >> y;
        if (x == 0 || y == 0) { break; }

        BranchList::iterator x_itr=branches.end(), y_itr=branches.end();
        for (BranchList::iterator itr=branches.begin(); itr!=branches.end() && (x_itr==branches.end() || y_itr==branches.end()); ++itr)
        {
            if (x_itr == branches.end() && itr->count(x) == 1) { x_itr = itr; }
            if (y_itr == branches.end() && itr->count(y) == 1) { y_itr = itr; }
        }

        if (x_itr != y_itr)
        {
            std::copy(y_itr->begin(), y_itr->end(), std::inserter(*x_itr, x_itr->begin()));
        }
        branches.erase(y_itr);
    }

    std::cout << (branches.size() - 1) << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void CORR_Error_Correction_In_Reads()
{
    std::ifstream input("input.txt");
    std::multiset<std::string> sequences;

    while (!input.eof())
    {
        std::string s;
        input >> s;
        if (!s.empty()) { sequences.insert(s); }
    }

    std::set<std::string> new_sequences;

    std::string s = *sequences.begin();
    while (true)
    {
        std::multiset<std::string>::const_iterator itr = std::lower_bound(sequences.begin(), sequences.end(), s);
        if (itr == sequences.end()) { break; }

        s = *itr;
        std::size_t count = sequences.count(s) + sequences.count(ReverseComplement(s));
        if (count > 1)
        {
            new_sequences.insert(s);
            sequences.erase(s);
            sequences.erase(ReverseComplement(s));
        }
        else
        {
            ++itr;
            if (itr == sequences.end()) { break; }
            s = *itr;
        }
    }

    for (std::multiset<std::string>::const_iterator old_itr=sequences.begin(); old_itr!=sequences.end(); ++old_itr)
    {
        std::string const& old_s = *old_itr;
        
        for (std::set<std::string>::const_iterator itr=new_sequences.begin(); itr!=new_sequences.end(); ++itr)
        {
            std::string const& new_s = *itr;

            {
                int count = 0;
                char const* p1 = old_s.c_str();
                char const* p2 = new_s.c_str();
                while (*p1 && *p2 && count < 2) { if (*p1++ != *p2++) { ++count; } }
                if (count == 1)
                {
                    //found it
                    std::cout << old_s << "->" << new_s << "\n";
                    break;
                }
            }

            {
                std::string const new_r = ReverseComplement(new_s);
                int count = 0;
                char const* p1 = old_s.c_str();
                char const* p2 = new_r.c_str();
                while (*p1 && *p2 && count < 2) { if (*p1++ != *p2++) { ++count; } }
                if (count == 1)
                {
                    //found it
                    std::cout << old_s << "->" << new_r << "\n";
                    break;
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void EVAL_Introduction_To_Expected_Value()
{
    std::ifstream input("input.txt");
    double m, n;
    input >> m >> n;

    while (!input.eof())
    {
        double d;
        input >> d;

        double ex = (n-m+1) * pow(d*d - d + 0.5, m);
        std::cout << std::fixed << std::setprecision(3) << ex << " ";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void INOD_Counting_Pylogenetic_Ancestors()
{
    int const n = 6346;
    std::cout << (n-2) << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void KMER_kMer_Composition()
{
    Sequences sequences = GetFasta("input.txt");
    std::string const& s = sequences.begin()->second;
    if (s.find_first_not_of("ACGT") != std::string::npos) { assert(false); }
    std::size_t size = s.size();

    std::ofstream output("output.txt", std::ios::trunc);

    std::map<std::string, std::size_t> m;
    std::string const alphabet = "ACGT";
    std::string kmer(4, ' ');
    for (int i=0; i!=4; ++i)
    {
        kmer[0] = alphabet[i];
        for (int j=0; j!=4; ++j)
        {
            kmer[1] = alphabet[j];
            for (int k=0; k!=4; ++k)
            {
                kmer[2] = alphabet[k];
                for (int l=0; l!=4; ++l)
                {
                    kmer[3] = alphabet[l];
                    m[kmer] = 0;
                }
            }
        }
    }
    assert(m.size() == 256);

    std::string::const_iterator end = s.end() - 3;
    for (std::string::const_iterator itr=s.begin(); itr!=end; ++itr)
    {

        std::string tmp(itr, itr+4);
        ++m[tmp];
    }

    for (std::map<std::string, std::size_t>::const_iterator itr=m.begin(); itr!=m.end(); ++itr)
    {
        output << itr->second << " ";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void LCSQ_Finding_A_Shared_Spliced_Motif()
{
    std::ifstream input("input.txt");
    std::string x, y;
    input >> x >> y;

    enum Direction
    {
        DirNone,
        DirDiag,
        DirLeft,
        DirUp,
        DirLeftUp
    };

    typedef std::pair<Direction, std::size_t> Cell;
    typedef std::vector<std::vector<Cell> > LcsTable;
    LcsTable t;
    t.resize(x.size() + 1);
    for (LcsTable::iterator itr=t.begin(); itr!=t.end(); ++itr)
    {
        itr->resize(y.size() + 1);
    }

    for (int i=0; i!=x.size()+1; ++i)
    {
        if (i<=x.size()) { t[i][0] = std::make_pair(DirNone, 0); }
        if (i<=y.size()) { t[0][i] = std::make_pair(DirNone, 0); }
    }

    for (std::size_t i=1; i!=x.size()+1; ++i)
    {
        std::cout << i << std::endl;
        for (std::size_t j=1; j!=y.size()+1; ++j)
        {
            Cell& current_element = t[i][j];

            char const xi = x[i-1];
            char const yj = y[j-1];

            if (xi == yj)
            {
                Cell const& upper_diagonal = t[i-1][j-1];
                current_element = std::make_pair(DirDiag, upper_diagonal.second + 1);
            }
            else
            {
                Cell const& up_set = t[i-1][j];
                Cell const& left_set = t[i][j-1];

                if      (up_set.second > left_set.second) { current_element = std::make_pair(DirUp, up_set.second); }
                else if (up_set.second < left_set.second) { current_element = std::make_pair(DirLeft, left_set.second); }
                else                                      { current_element = std::make_pair(DirLeftUp, up_set.second); }
            }

            int z=0;
        }
    }

    std::string s;
    s.reserve(std::max(x.size(), y.size()));


    std::size_t a=x.size();
    std::size_t b=y.size();
    std::size_t length = t[a][b].second;
    while (a && b)
    {
        Cell const& current_cell = t[a][b];
        if (current_cell.first == DirDiag)
        {
            s.append(1, x[a-1]);
            --a; --b;
        }
        else if (current_cell.first == DirUp)
        {
            --a;
        }
        else
        {
            --b;
        }
    }
    std::reverse(s.begin(), s.end());

    std::ofstream output("output.txt", std::ios::trunc);
    output << s << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void LEXV_Ordering_Strings_Of_Varying_Length_Lexicographically()
{
    char const s[] = "YOZEDPLUGKQN";
    int n = 4;

    std::ofstream output("output.txt", std::ios::trunc);
    char const* end = s+12;
    char buff[20] = {0};

    for (char const* i0=s; i0!=end; ++i0)
    {
        buff[0] = *i0; buff[1] = 0;
        output << buff << "\n";
        if (n < 2) { continue; }
        for (char const* i1=s; i1!=end; ++i1)
        {
            buff[1] = *i1; buff[2] = 0;
            output << buff << "\n";
            if (n < 3) { continue; }
            for (char const* i2=s; i2!=end; ++i2)
            {
                buff[2] = *i2; buff[3] = 0;
                output << buff << "\n";
                if (n < 4) { continue; }
                for (char const* i3=s; i3!=end; ++i3)
                {
                    buff[3] = *i3; buff[4] = 0;
                    output << buff << "\n";
                    if (n < 5) { continue; }
                    for (char const* i4=s; i4!=end; ++i4)
                    {
                        buff[4] = *i4; buff[5] = 0;
                        output << buff << "\n";
                        if (n < 6) { continue; }
                        for (char const* i5=s; i5!=end; ++i5)
                        {
                            buff[5] = *i5; buff[6] = 0;
                            output << buff << "\n";
                            if (n < 7) { continue; }
                            for (char const* i6=s; i6!=end; ++i6)
                            {
                                buff[6] = *i6; buff[7] = 0;
                                output << buff << "\n";
                                if (n < 8) { continue; }
                                for (char const* i7=s; i7!=end; ++i7)
                                {
                                    buff[7] = *i7; buff[8] = 0;
                                    output << buff << "\n";
                                    if (n < 9) { continue; }
                                    for (char const* i8=s; i8!=end; ++i8)
                                    {
                                        buff[8] = *i8; buff[9] = 0;
                                        output << buff << "\n";
                                        if (n < 10) { continue; }
                                        for (char const* i9=s; i9!=end; ++i9)
                                        {
                                            buff[9] = *i9; buff[10] = 0;
                                            output << buff << "\n";
                                            if (n < 11) { continue; }
                                            for (char const* i10=s; i10!=end; ++i10)
                                            {
                                                buff[10] = *i10; buff[11] = 0;
                                                output << buff << "\n";
                                                if (n < 12) { continue; }
                                                for (char const* i11=s; i11!=end; ++i11)
                                                {
                                                    buff[11] = *i11; buff[12] = 0;
                                                    output << buff << "\n";
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void SORT_helper_build_table()
{
    return;
    typedef std::vector<char>                       Sequence;
    typedef std::pair<std::size_t, std::size_t>     Reversal;
    typedef std::vector<Reversal>                   ReversalList;
    typedef std::pair<std::size_t, ReversalList>    ReversalDetails;
    typedef std::map<Sequence, ReversalDetails>     Table;
    Table table;

    std::size_t distance = 0;
    Sequence start = boost::assign::list_of('0')('1')('2')('3')('4')('5')('6')('7')('8')('9');
    table[start] = ReversalDetails(distance, ReversalList());

    std::size_t new_entries = 1;
    while (new_entries)
    {
        std::cout << distance << std::endl;
        new_entries = 0;
        for (Table::iterator itr=table.begin(); itr!=table.end(); ++itr)
        {
            ReversalDetails& details = itr->second;
            if (details.first == distance)
            {
                Sequence s = itr->first;
                for (Sequence::iterator p1=s.begin(); p1!=(s.end()-1); ++p1)
                {
                    for (Sequence::iterator p2=p1+1; p2!=s.end(); ++p2)
                    {
                        std::reverse(p1, p2+1);
                        if (table.count(s) == 0)
                        {
                            table[s] = std::make_pair(distance + 1, details.second);
                            table[s].second.push_back(Reversal(std::distance(s.begin(), p1), std::distance(s.begin(), p2)));
                            ++new_entries;
                        }
                        std::reverse(p1, p2+1);
                    }
                }
            }
        }
        ++distance;
    }

    std::cout << "table built" << std::endl;

    std::ofstream file("table2.txt", std::ios::trunc);
    for (Table::const_iterator itr=table.begin(); itr!=table.end(); ++itr)
    {
        file.write(&itr->first[0], 10);
        file << " " << static_cast<char>(itr->second.first + '0');
        for (ReversalList::const_iterator itr2=itr->second.second.begin(); itr2!=itr->second.second.end(); ++itr2)
        {
            file << " " << static_cast<char>(itr2->first + '0') << " " << static_cast<char>(itr2->second + '0');
        }
        file << "\n";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void SORT_Sorting_By_Reversals()
{
    //SORT_helper_build_table();

    // load in table
    typedef std::pair<std::size_t, std::size_t>     Reversal;
    typedef std::vector<Reversal>                   ReversalList;
    typedef std::pair<std::size_t, ReversalList>    ReversalDetails;
    typedef std::map<long long, ReversalDetails>    Table;
    Table table;

    std::cout << "loading table" << std::endl;
    std::ifstream ftable("table2.txt");

    std::string line;
    while (std::getline(ftable, line))
    {
        if (!line.empty())
        {
            std::istringstream iss(line);
            long long a;
            std::size_t b;
            iss >> a >> b;
            ReversalList list;
            for (std::size_t i=0; i!=b; ++i)
            {
                std::size_t x, y;
                iss >> x >> y; 
                list.push_back(Reversal(x, y));
            }
            table[a] = ReversalDetails(b, list);
            if (a % 1000000000 == 0) { std::cout << a << std::endl; }
        }
    }

    //assert(table.size() == 3628800);
    std::cout << "finished loading table" << std::endl;

    // load the input   
    std::ifstream input("input.txt");

    while (true)
    {
        // read first set of numbers
        std::vector<long long> v1(10);
        input >> v1[0] >> v1[1] >> v1[2] >> v1[3] >> v1[4] >> v1[5] >> v1[6] >> v1[7] >> v1[8] >> v1[9];
        --v1[0]; --v1[1]; --v1[2]; --v1[3]; --v1[4]; --v1[5]; --v1[6]; --v1[7]; --v1[8]; --v1[9]; 

        // read second set of numbers
        std::vector<long long> v2(10);
        input >> v2[0] >> v2[1] >> v2[2] >> v2[3] >> v2[4] >> v2[5] >> v2[6] >> v2[7] >> v2[8] >> v2[9];
        --v2[0]; --v2[1]; --v2[2]; --v2[3]; --v2[4]; --v2[5]; --v2[6]; --v2[7]; --v2[8]; --v2[9]; 

        if (input.eof())
        {
            break;
        }

        std::vector<long long> v3(10);
        for (long long i=0; i!=10; ++i)
        {
            long long x = v1[static_cast<unsigned int>(i)];
            std::vector<long long>::iterator itr = std::find(v2.begin(), v2.end(), x);
            v3[std::distance(v2.begin(), itr)] = i;
        }

        // convert v3 to a number
        long long num = (((((((((v3[0])*10+v3[1])*10+v3[2])*10+v3[3])*10+v3[4])*10+v3[5])*10+v3[6])*10+v3[7])*10+v3[8])*10+v3[9];

        // and look up the answer
        ReversalDetails const& details = table[num];
        std::cout << details.first << "\n";
        for (ReversalList::const_iterator itr=details.second.begin(); itr!=details.second.end(); ++itr)
        {
            std::cout << (itr->first+1) << " " << (itr->second+1) << "\n";
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void EDIT_Edit_Distance()
{
    std::ifstream input("input.txt");
    std::string x, y;
    input >> x >> y;

    enum Direction
    {
        DirNone,
        DirDiag,
        DirLeft,
        DirUp,
        DirLeftUp
    };

    typedef std::pair<Direction, std::size_t> Cell;
    typedef std::vector<std::vector<Cell> > LcsTable;
    LcsTable t;
    t.resize(x.size() + 1);
    for (LcsTable::iterator itr=t.begin(); itr!=t.end(); ++itr)
    {
        itr->resize(y.size() + 1);
    }

    for (int i=0; i!=x.size()+1; ++i)
    {
        if (i<=x.size()) { t[i][0] = std::make_pair(DirNone, 0); }
        if (i<=y.size()) { t[0][i] = std::make_pair(DirNone, 0); }
    }

    for (std::size_t i=1; i!=x.size()+1; ++i)
    {
        //std::cout << i << std::endl;
        for (std::size_t j=1; j!=y.size()+1; ++j)
        {
            Cell& current_element = t[i][j];

            char const xi = x[i-1];
            char const yj = y[j-1];

            if (xi == yj)
            {
                Cell const& upper_diagonal = t[i-1][j-1];
                current_element = std::make_pair(DirDiag, upper_diagonal.second + 1);
            }
            else
            {
                Cell const& up_set = t[i-1][j];
                Cell const& left_set = t[i][j-1];

                if      (up_set.second > left_set.second) { current_element = std::make_pair(DirUp, up_set.second); }
                else if (up_set.second < left_set.second) { current_element = std::make_pair(DirLeft, left_set.second); }
                else                                      { current_element = std::make_pair(DirLeftUp, up_set.second); }
            }

            int z=0;
        }
    }

    std::string s;
    s.reserve(std::max(x.size(), y.size()));

    std::size_t a=x.size();
    std::size_t b=y.size();
    std::size_t length = t[a][b].second;
    while (a && b)
    {
        Cell const& current_cell = t[a][b];
        if (current_cell.first == DirDiag)
        {
            s.append(1, x[a-1]);
            --a; --b;
        }
        else if (current_cell.first == DirUp)
        {
            --a;
        }
        else
        {
            --b;
        }
    }
    std::reverse(s.begin(), s.end());
    std::ofstream output("output.txt", std::ios::trunc);
    output << s << std::endl;


    x = "z" + x;
    y = "z" + y;

    std::size_t edit_distance = 0;
    std::string::size_type pos_x = 0, pos_y = 0;
    for (std::string::const_iterator itr=s.begin(); itr!=s.end(); ++itr)
    {
        std::string::size_type pos_x2 = x.find(*itr, pos_x + 1);
        std::string::size_type pos_y2 = y.find(*itr, pos_y + 1);

        std::string const xx = x.substr(pos_x, pos_x2 - pos_x);
        std::string const yy = y.substr(pos_y, pos_y2 - pos_y);

        std::size_t max_substr = std::max(xx.size(), yy.size());
        edit_distance += max_substr - 1;

        pos_x = pos_x2;
        pos_y = pos_y2;
    }

    std::cout << edit_distance << std::endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
int EDIT_recurse(std::string const& s, std::string const& t, std::string::size_type i, std::string::size_type j, bool clear_memo = false)
{
    static int rows = i;
    static std::vector<int> memo(rows*j, -1);
    
    if (clear_memo)
    {
        rows = i;
        memo.clear();
        memo.resize(rows*j, -1);
    }

    if      (i == 0) { return j; }
    else if (j == 0) { return i; }
    else
    {
        int* p = &memo[(rows-1)*j + i - 1];
        if (*p != -1) { return *p; }

        *p = EDIT_recurse(s, t, i-1, j-1) + (s[i-1] == t[j-1] ? 0 : 1);
        *p = std::min(*p, EDIT_recurse(s, t, i-1, j) + 1);
        *p = std::min(*p, EDIT_recurse(s, t, i, j-1) + 1);
        return *p;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void EDIT_Edit_Distance2()
{
    std::ifstream input("input.txt");
    std::string x, y;
    input >> x >> y;

    DWORD start = GetTickCount();
    int result = 0;
    for (int i=0; i<1000; ++i)
    {
        result += EDIT_recurse(x, y, x.size(), y.size(), true);
    }
    DWORD end = GetTickCount();
    int ms = end - start;
    std::cout << (result / 1000) << ":  calculation time was " << ms << " milliseconds" << std::endl;
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
void SPEC_Inferring_Protein_From_Spectrum()
{
    std::ifstream input("input.txt");
    double d;
    std::vector<double> v;
    while (!input.eof())
    {
        d = -1.0;
        input >> d;
        if (d != -1.0)
        {
            v.push_back(d);
        }
    }

    for (std::vector<double>::const_iterator itr=v.begin() + 1; itr!=v.end(); ++itr)
    {
        double const mass = *itr - *(itr-1);

        char c = 0;
        double delta = 999999.0;
        for (MonoisotopicMasses::const_iterator itr2=masses.begin(); itr2!=masses.end(); ++itr2)
        {
            if (abs(itr2->second - mass) < delta)
            {
                c = itr2->first;
                delta = abs(itr2->second - mass);
            }
        }
        std::cout << c;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void FULL_Inferring_Peptide_From_Full_Spectrum()
{
    std::ifstream input("input.txt");
    double peptide_mass;
    input >> peptide_mass;

    std::vector<double> v;
    while (!input.eof())
    {
        double d = -1.0;
        input >> d;
        if (d != -1.0)
        {
            v.push_back(d);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char** argv)
{
    try
    {
        // P01_Counting_Nucleotides();
        // P02_RNA_Transscription();
        // P03_Reverse_Complement();
        // P04_Counting_Point_Mutations();
        // P05_Protein_Translation();
        // P06_Finding_Pattern_In_DNA();
        // P07_Consensus_And_Profile();
        // P08_GC_Content(argc, argv);
        // P09_Overlap_Graphs();
        // P10_Finding_A_Shared_Motif();
        // P11_Inferring_mRNA_from_Protein();
        // P12_Open_Reading_Frames();
        // P13_Enumerating_Gene_Orders();
        // P14_Calculating_Protein_Mass();
        // P15_Locating_Restriction_Sites();
        // P16_RNA_Splicing();
        // P17_Speeding_Up_Motif_Finding();
        // P18_Enumerating_Kmers_Lexicographically();
        // P19_Genome_Assembly_As_Shortest_Substring_2();
        // P20_Reversal_Distance();
        // PROB_Introduction_To_Probability();
        // SIGN_Enumerating_Oriented_Gene_Orderings();
        // SSEQ_Finding_A_Spliced_Motif();
        // TREE_Completing_A_Tree();
        // CORR_Error_Correction_In_Reads();
        // EVAL_Introduction_To_Expected_Value();
        // INOD_Counting_Pylogenetic_Ancestors();
        // KMER_kMer_Composition();
        // LCSQ_Finding_A_Shared_Spliced_Motif();
        // LEXV_Ordering_Strings_Of_Varying_Length_Lexicographically();
        // SORT_Sorting_By_Reversals();
        // EDIT_Edit_Distance2();
        // SPEC_Inferring_Protein_From_Spectrum();
        FULL_Inferring_Peptide_From_Full_Spectrum();



        std::cout << "\n\nPress any key to exit..." << std::endl;
        _getch();
        return 0;
    }
    catch (std::exception& e)
    {
        std::cout << "main() - caught std::exception: " << e.what() << std::endl;
        return 0;
    }
    catch (...)
    {
        std::cout << "main() - caught unknown exception" << std::endl;
        return 0;
    }
}


